<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>麦桃子的部落格</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="麦桃子的部落格">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="麦桃子的部落格">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="麦桃子的部落格">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="麦桃子的部落格" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xruqa.com1.z0.glb.clouddn.com/IMG_myphoto.JPG" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mai Taozi</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">越努力 越幸运</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mai Taozi</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xruqa.com1.z0.glb.clouddn.com/IMG_myphoto.JPG" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Mai Taozi</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Java面试（下）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/18/Java面试（下）/" class="article-date">
  	<time datetime="2017-01-18T02:55:26.000Z" itemprop="datePublished">2017-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/18/Java面试（下）/">Java面试（下）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="28-wait-和sleep-的区别"><a href="#28-wait-和sleep-的区别" class="headerlink" title="28. wait()和sleep()的区别"></a>28. wait()和sleep()的区别</h3><p>1）这两个方法来自不同的类，分别是Sleep来自Thread类，wait来自Object类。sleep是Thread的静态类方法，谁调用谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</p>
<p>2）锁：最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以同步控制块或者方法。sleep不出让系统资源，wait是进入线程等待吃等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，要等待其他县城调用notify/notifyAll唤醒等待池中的所有县城，才会进入就绪队列等待OS分配系统资源。sleep（milliseconds）可以用时间指定使它自动唤醒过来，如果时间不到只能用interrupt（）强行打断。<br>Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。</p>
<p>3）使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。</p>
<pre><code>synchronized（x）{
     x.notify()
     //或者wait()
}
</code></pre><h3 id="29-foreach与正常for循环效率对比"><a href="#29-foreach与正常for循环效率对比" class="headerlink" title="29. foreach与正常for循环效率对比"></a>29. foreach与正常for循环效率对比</h3><p>foreach语句是java5新增的，在遍历数组，集合的时候，foreach有不错的性能。foreach是for语句的简化，但是foreach并不能替代for循环，可以这么说，任何foreach都鞥改写为for循环，但是反之则行不通。foreach 不是java中的关键字，foreach的循环对象一般是一个集合，List，ArrayList,LinkedList,Vector数组等。</p>
<h3 id="30-Java-IO与NIO"><a href="#30-Java-IO与NIO" class="headerlink" title="30. Java IO与NIO"></a>30. Java IO与NIO</h3><p>新的输入/输出（NIO）库是在JDK1.4种引入的。NIO弥补了原来的I/O的不足，它在标准java代码中提供了高速的，面向块的I/O。</p>
<p>面向流与面向缓冲</p>
<blockquote>
<p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲的。Java IO面向流意味着每从流中读一个或多个字节，直至读取所有字节，他们没有被缓存在任何地方。此外，它不能前后移动流中的数据，如果需要前后移动流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同，数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据，而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
</blockquote>
<p>阻塞和非阻塞IO</p>
<blockquote>
<p>Java IO的各种流是阻塞的，这意味着，当一个线程调用read()或write()时，该线程被阻塞，知道有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至线程变得可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待他完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道。</p>
</blockquote>
<p>选择器（Selectors）</p>
<blockquote>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道，这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
</blockquote>
<h3 id="31-反射的作用与原理。"><a href="#31-反射的作用与原理。" class="headerlink" title="31. 反射的作用与原理。"></a>31. 反射的作用与原理。</h3><p>1）什么是Java的反射机制<br>java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers(诸如public，static等)，superclass(例如Object)，实现interfaces(例如Cloneable)，也包括field和methods的所有信息，并可于运行时改变fileds内容或唤起methods。Java反射机制容许程序在运行时加载，探知，使用编译器完全未知的classes。换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。</p>
<p>2）JAVA反射机制提供了什么功能</p>
<blockquote>
<p>在运行时判断任意一个对象所属的类<br>在运行时构造任意一个类的对象<br>在运行时判断任意一个类所具有的成员变量和方法<br>在运行时调用任一个对象的方法<br>在运行时创建新类对象</p>
</blockquote>
<p>在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</p>
<pre><code>Class Type{
    public int pubIntField;
    public String pubStringField;
    private int prvIntField;

    public Type(){
       Log(&quot;Default Constructor&quot;);
    }
    Type(int arg1,String arg2){
        pubIntField=arg1;
        pubStringField=arg2;

        Log(&quot;Constructor with parameters&quot;);
    }
    public void setIntField(int val){
       this.prvIntField=val;
    }
    public int getIntField(){
         return prvIntField;
    }
    private void Log(String msg){
        System.out.println(&quot;Type:&quot;+msg);
    }
}

class ExtendType extends type{
     public int pubIntExtendField;
     public String pubStringExtendField;
     private int prvIntExtendField;

     public ExtendType(){
        Log(&quot;Default Constructor&quot;);
     }
     public ExtendType(int arg1,String arg2){
        pubIntExtendField=arg1;
        pubStringExtendField=arg2;
        Log(&quot;Constructor with parameters&quot;);
    }
    public void setIntExtendField(int field7){
        this.prvIntExtendField=field7;
    }
    public int getIntExtendField(){
        return prvIntExtendField;
    }
    private void Log(String msg){
        System.out.pringln(&quot;ExtendType:&quot;+msg);
    }
}
</code></pre><p>1)获取类的Class对象<br>Class类的实例表示正在运行的Java应用程序中的类和接口，获取类的Class对象有多种方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用getClass</td>
<td style="text-align:left">Boolean var1=true;  Class&lt;?&gt;classType2=var1.getClass(); System.out.println(classType2);   输出：class java.lang.Boolean</td>
</tr>
<tr>
<td>运用.class语法</td>
<td style="text-align:left">Class&lt;?&gt; classType4=Boolean.class;      System.out.println(classType4); 输出：class java.lang.Boolean</td>
</tr>
<tr>
<td>运用static method Class.forName()</td>
<td style="text-align:left">Class&lt;?&gt; classType5=class.forName(“java.lang.Boolean”);System.out.println(classType5);输出：class java.lang.Boolean</td>
</tr>
<tr>
<td>运行primitive wrapper classes的Type语法</td>
<td style="text-align:left">Class&lt;?&gt; classType3=Boolean.TYPE;                  System.out.println(classType3);    输出：boolean</td>
</tr>
</tbody>
</table>
<p>2）获取类的Fields<br>可以通过反射机制得到某个类的某个属性，然后改变对应于这个类的某个实例的该属性值。Java的Class<t>类提供了几个方法获取类的属性</t></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>public FieldgetField(String name)</td>
<td style="text-align:left">返回一个Field对象，它反映此Class对象所表示的类或接口的制定公共成员字段</td>
</tr>
<tr>
<td>public Field[] getFields()</td>
<td style="text-align:left">返回一个包含某些Field对象的数组，这些对象反映此Class对象所表示的类或接口的所有可访问公共字段</td>
</tr>
<tr>
<td>public FieldgetDeclaredField(String name)</td>
<td style="text-align:left">返回一个Field对象，该对象反映此Class对象所表示的类或接口的指定已声明字段</td>
</tr>
<tr>
<td>public Field[] getDeclaredFields()</td>
<td style="text-align:left">返回Field对象的一个数组，这些对象反映此Class对象所表示的类或接口所声明的所有字段</td>
</tr>
</tbody>
</table>
<pre><code>Class&lt;?&gt; classType=ExtendType.class;
//使用getField获取属性
Field[] fields=classType.getFields();
for(Field f:fields){
    System.out.println(f);
}
System.out.println();
//使用getDeclareFields获取属性
fields=classType.getDeclareFields();
for(Field f:fields){
{
   System.out.println(f);
}

输出：
public int com.quincy.ExtendType.pubIntExtendField
public java.lang.String com.quincy.ExtendType.pubStringExtendField
public int com.quincy.Type.pubIntField
public java.lang.String com.quincy.Type.pubStringField
public int com.quincy.ExtendType.pubIntExtendField
public java.lang.String com.quincy.ExtendType.pubStringExtendField
private int com.quincy.ExtendType.prvIntExtendField
</code></pre><p>可见getFields和getDeclaredFields区别：<br>getFields返回的是申明为public的属性，包括父类中定义，getDeclaredFields返回的是指定类定义的所有定义的属性，不包括父类的。</p>
<p>3）获取类的Method<br>通过反射机制得到某个类的某个方法，然后调用对应于这个类的某个实例的该方法 Class<t> 类提供了几个方法获取类的方法</t></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>public MethodgetMethod(String name,Class&lt;?&gt; parameterTypes)</td>
<td style="text-align:left">返回一个Method对象，它反映此Class对象所表示的类或接口的指定公共成员方法</td>
</tr>
<tr>
<td>public Method[] getMethods()</td>
<td style="text-align:left">返回一个包含某些Method对象的数组，这些对象反应此Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些类或接口）的公共member方法</td>
</tr>
<tr>
<td>public MethodgetDeclareMethod(Stringname,Class&lt;?&gt;… parameterTypes)</td>
<td style="text-align:left">返回一个Method对象，该对象反应此Class对象所表示的类或借口的指定已声明方法</td>
</tr>
<tr>
<td>public Method[] getDeclaredMethods()</td>
<td style="text-align:left">返回Method对象的一个数组，这些对象反映此Class对象表示的类或接口声明的所有方法，包括公共，保护，默认（包）访问和私有方法，但不包括继承方法</td>
</tr>
</tbody>
</table>
<pre><code>//使用getMethods获取函数
Class&lt;?&gt; classType=ExtendType.class;
Method[] methods=classType.getMethods();
for(Method m:methods){
    System.out.println(m);
}
System.out.println();

//使用getDeclaredMethods获取函数
methods=classType.getDeclaredMethods();
for(Method m:methods){
{
   System.out.println(m);
}

输出
public void com.quincy.ExtendType.setIntExtendField(int)
public int com.quincy.ExtendType.getIntExtendField()
public void com.quincy.Type.setIntField(int)
public int com.quincy.Type.getIntField()
public final native void java.lang.Object.wait(long) throws      java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
private void com.quincy.ExtendType.Log(java.lang.String)
public void com.quincy.ExtendType.setIntExtendField(int)
public int com.quincy.ExtendType.getIntExtendField()
</code></pre><p>4）获取类的Constructor<br>通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例<br>Class<t> 类提供了几个方法获取类的构造器</t></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)</t></td>
<td style="text-align:left">返回一个Constructor对象，它反映此Class对象所表示的类的指定公共构造方法</td>
</tr>
<tr>
<td>public Constructor&lt;?&gt;[] getConstructors()</td>
<td style="text-align:left">返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法</td>
</tr>
<tr>
<td>public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</t></td>
<td style="text-align:left">返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法</td>
</tr>
<tr>
<td>public Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td style="text-align:left">返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法</td>
</tr>
</tbody>
</table>
<pre><code>// 使用getConstructors获取构造器    

Constructor&lt;?&gt;[] constructors = classType.getConstructors();  
for (Constructor&lt;?&gt; m : constructors)  
{  
    System.out.println(m);  
}  

System.out.println();  
// 使用getDeclaredConstructors获取构造器     
constructors = classType.getDeclaredConstructors();  
for (Constructor&lt;?&gt; m : constructors)  
{  
    System.out.println(m); 
}  

输出：  
public com.quincy.ExtendType()  
public com.quincy.ExtendType()
com.quincy.ExtendType(int,java.lang.String)  

...
</code></pre><p>反射的作用：反射可以增加代码的灵活性，通过反射可以使系统和插件解耦，如Spring就是使用反射来控制反转的（IOC）；<br>什么是反射：java运行阶段的程序对自身的一种审查能力</p>
<h3 id="32-泛型常用特点"><a href="#32-泛型常用特点" class="headerlink" title="32. 泛型常用特点"></a>32. 泛型常用特点</h3><p>List<string>能否转为List<object>? </object></string></p>
<p>泛型的种类：泛型类，泛型接口，泛型方法。Java泛型被引入的好处是安全简单。增加代码的复用性。（泛型解决了方法的重载问题：public void write(Integer i,Integer[] ia);public void write(Double d,Double[] da);的泛型版本为public<t> void write(T t,T[] ta)）</t></p>
<p>为什么要引入泛型:在java1.5之前，如果一个方法的参数中要支持任意类型，则一般用Object类来作为参数的类型，因此在运行的时候就要进行类型转换。这种自动转换类型容易出现当变异的时候不会报错，而运行的时候会报错，这是一个安全隐患。在java中弗雷是可以转换成子类的而且不报错，调用的时候出错运行时才能检查到。</p>
<p>泛型的好处是在编译的时候检查类型安全（类型检查是保证类型转化是可以正确转换的），并且所有的墙纸转换都是自动和隐式的，提高代码的重用率。</p>
<p>泛型信息在编译的时候会被自动擦除，也就是在字节码中没有泛型的信息，并使用其限定类型替换（无限定类型用Object），如pulic T fun(T t)替换成public Object fun(Object t),限定类型指的是T extend Father,则用Father替换T。</p>
<p>泛型主要的体现还是在类型安全的检查与限定，如List<string>,那我们就只能放入String类型的，这里就体现了类型检查</string></p>
<p>List<string>不能List<object>,因为泛型并不具有继承性，只是一个限定的作用。</object></string></p>
<h3 id="33-解析XML的几种方式的原理与特点：DOM、SAX、PULL。"><a href="#33-解析XML的几种方式的原理与特点：DOM、SAX、PULL。" class="headerlink" title="33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。"></a>33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。</h3><p>1.DOM是基于树的解析，DOM是把XML全部加载到内存中建立一棵树之后再进行处理。所以DOM不适合处理大型的XML（会产生内存的急剧膨胀），这样可以随时修改xml文件内容。<br>2.SAX基于事件的解析，sax解析一行一行的读取xml文件开始标记的时候执行startElement方法，然后执行对应解析方法character方法，当遇到结束表示符就调用endElement方法，所以是基于事件型解析，SAX不必把全部的xml都加载到内存中，但是SAX的缺点也很明显，它只能对文件顺序解析一遍，不支持对文件的随意存取。SAX也仅仅能够读取文件的内容，并不能修改内容。DOM可以随意修改文件树。（主要用于读取xml文件）<br>3.SAX和DOM不是相互排斥的，可以使用DOM来创建SAX事件流，也可以使用SAX来创建DOM树。</p>
<h3 id="34-Java与C-对比"><a href="#34-Java与C-对比" class="headerlink" title="34. Java与C++对比"></a>34. Java与C++对比</h3><p>1.java比C++程序可靠性更高<br>2.java语言中没有指针的概念<br>3.java用接口（Interface）技术取代C++程序中的多继承性<br>4.Java语言不需要程序对内存进行分配和回收，Java中自动回收内存，而C++中要调用new和delete来申请和释放内存，如果对内存分配与申请掌握不好就容易报错。<br>5.异常：JAVA中的一场机制用于捕获意外事件，增强系统容错能力</p>
<pre><code>try{
    //可能产生例外的代码 
}
catch(exceptionType name){ 
    //处理
} 
</code></pre><p>其中exceptionType表示异常类型。而C++则没有如此方便的机制<br>6.“可怕”的goto语句是C和C++的遗物，它是该语言技术上的合法部分，引用goto语句引起了程序结构的混乱，不易理解，goto语句主要用于无条件转移子程序和多结构分支技术。Java不提供goto语句，它虽然指定goto作为关键字，但不支持他的使用，是程序简洁易懂。</p>
<h3 id="35-Java1-7与1-8新特性"><a href="#35-Java1-7与1-8新特性" class="headerlink" title="35 Java1.7与1.8新特性"></a>35 Java1.7与1.8新特性</h3><p>1.jdk1.7语法上</p>
<p>1）二进制变量的表示，支持将整数类型用二进制来表示，用0b开头</p>
<pre><code>//所有整数 int，short，long，byte都可以用二进制表示
//an 8-bit &apos;byte&apos; value;
byte aByte=(byte)0b00100001;

//a 16-bit &apos;short&apos; value;
short aShort =(short) 0b1010000101000101;

//some 32-bit &apos;int&apos; value;
intanInt1=0b10100001010001011010000101000101;
intanInt2=0b101;
intanInt3 = 0B101; // The B can be upper or lower case.

//a 64-bit &apos;long&apos; value.Note the &apos;L&apos; suffix:
long aLong=0b1010000101000101101000010100010110100001010001011010000101000101L;

//二进制在数组等的使用
final int[] phases = { 0b00110001, 0b01100010, 0b11000100, 0b10001001,
0b00010011, 0b00100110, 0b01001100, 0b10011000 };
</code></pre><p>2）switch语句支持string类型</p>
<pre><code>public static String getTypeOfDayWithSwitchStatement(String dayOfWeekArg) {
     String typeOfDay;
     switch (dayOfWeekArg) {
         case &quot;Monday&quot;:
             typeOfDay = &quot;Start of work week&quot;;
             break;
         case &quot;Tuesday&quot;:
         case &quot;Wednesday&quot;:
         case &quot;Thursday&quot;:
             typeOfDay = &quot;Midweek&quot;;
             break;
         case &quot;Friday&quot;:
             typeOfDay = &quot;End of work week&quot;;
             break;
         case &quot;Saturday&quot;:
         case &quot;Sunday&quot;:
             typeOfDay = &quot;Weekend&quot;;
             break;
         default:
             throw new IllegalArgumentException(&quot;Invalid day of the week: &quot; + dayOfWeekArg);
     }
     return typeOfDay;
}
</code></pre><p>3）try-with-resource语句<br>注意：实现java.lang.AutoCloseable接口的资源可以放到try中，跟final里面的关闭资源类似；按照声明逆序关闭资源；try块抛出的异常通过Throwalbe.getSuppossed获取</p>
<pre><code>try (java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);
java.io.BufferedWriter writer = java.nio.file.Files 
.newBufferedWriter(outputFilePath, charset)) 
{
// Enumerate each entry
   for (java.util.Enumeration entries = zf.entries(); entries
  .hasMoreElements();) {
       // Get the entry name and write it to the output file
       String newLine = System.getProperty(&quot;line.separator&quot;);
       String zipEntryName = ((java.util.zip.ZipEntry) entries
       .nextElement()).getName() + newLine;
    writer.write(zipEntryName, 0, zipEntryName.length());
   }
}
</code></pre><p>4）catch多个异常 说明：Catch异常类型为final，生成Bytecode会比多个catch小，rethrow时保持异常类型</p>
<pre><code>public static void main(String[] args) throws Exception {
try {
testthrows();
} catch (IOException | SQLException ex) {
throw ex;
}
}
public static void testthrows() throws IOException, SQLException {
}
</code></pre><p>5）数字类型的下划线表示 更友好的表示方式，不过要注意下划线添加的一些标准，可以参考下面的示例</p>
<pre><code>long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi = 3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010; 
//float pi1 = 3_.1415F; // Invalid; cannot put underscores adjacent to a decimal point
//float pi2 = 3._1415F; // Invalid; cannot put underscores adjacent to a decimal point
//long socialSecurityNumber1= 999_99_9999_L; // Invalid; cannot put underscores prior to an L suffix 
//int x1 = _52; // This is an identifier, not a numeric literal
int x2 = 5_2; // OK (decimal literal)
//int x3 = 52_; // Invalid; cannot put underscores at the end of a literal
int x4 = 5_______2; // OK (decimal literal) 
//int x5 = 0_x52; // Invalid; cannot put underscores in the 0x radix prefix
//int x6 = 0x_52; // Invalid; cannot put underscores at the beginning of a number
int x7 = 0x5_2; // OK (hexadecimal literal)
//int x8 = 0x52_; // Invalid; cannot put underscores at the end of a number 
int x9 = 0_52; // OK (octal literal)
int x10 = 05_2; // OK (octal literal)
</code></pre><p>6）泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的反省类型，只用&lt;&gt;就可以了</p>
<pre><code>//使用泛型前
List strList=new ArrayList();
List&lt;String&gt; strList4=new ArrayList&lt;String&gt;();
List&lt;Map&lt;String,List&lt;String&gt;&gt;&gt; strList5=new ArrayList&lt;Map&lt;String,List&lt;String&gt;&gt;&gt;();

//编译器使用尖括号（&lt;&gt;）推断类型
List&lt;String&gt; strList0=new ArrayList&lt;String&gt;();
List&lt;Map&lt;String,List&lt;String&gt;&gt;&gt; strList1=new ArrayList&lt;Map&lt;String,List&lt;String&gt;&gt;&gt;();
List&lt;String&gt; strList2=new ArrayList&lt;&gt;();
List&lt;Map&lt;String,List&lt;String&gt;&gt;&gt; strList3=new ArrayList&lt;&gt;();
List&lt;String&gt; list=new ArrayList&lt;&gt;();
list.add(&quot;A&quot;);
// The following statement should fail since addAll expects
// Collection
</code></pre><p>7)在可变参数方法中传递非具体化参数，改进编译警告和错误<br>heap pollution 指一个变量被指向另外一个不是相同类型的变量</p>
<pre><code>List l = new ArrayList&lt;Number&gt;();
List&lt;String&gt; ls = l; // unchecked warning
l.add(0, new Integer(42)); // another unchecked warning
String s = ls.get(0); // ClassCastException is thrown
Jdk7:
public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) {
      for (T x : elements) {
          listArg.add(x);
      }
}
</code></pre><p>你会得到一个warning<br>warning: [varargs] Possible heap pollution from parameterized vararg type<br>    要消除警告，可以有三种方式<br>    1.加 annotation @SafeVarargs<br>    2.加 annotation @SuppressWarnings({“unchecked”, “varargs”})<br>    3.使用编译器参数 –Xlint:varargs;</p>
<p>8）信息更丰富的回溯追踪，就是上面try语句和里面的语句同时抛出异常时，异常栈的信息</p>
<p>2 NIO2的一些新特性</p>
<ul>
<li>java.nio.file和java.nio.file.attribute包，支持更详细属性，比如权限，所有者</li>
<li>symbolic and hard links支持</li>
<li>Path访问文件系统，Files支持各种文件操作</li>
<li>搞笑的访问metadata信息</li>
<li>递归查找文件树，文件扩展搜索</li>
<li>文件系统修改通知机制</li>
<li>File类操作API兼容</li>
<li>文件随机访问增强 mapping a region,local a region,绝对位置读取</li>
<li>AIO Reactor（基于事件）和Proactor</li>
</ul>
<p>1）IO and new IO监听文件系统变化通知<br>通过FileSystems.getDefault().newWatchService()获取watchService，然后将需要监听的path目录注册到这个watchservice中，对于这个目录的文件修改，新增，删除等实践可以配置，然后就自动能监听到响应的事件。</p>
<p>2）IO and New IO遍历文件树，通过继承SimpleFileVisitor类，实现事件遍历目录树的操作，然后通过Files.walkFileTree(listDir, opts, Integer.MAX_VALUE, walk);这个API来遍历目录树</p>
<p>3） AIO异步IO 文件和网络 异步IO在java<br> NIO2实现了，都是用AsynchronousFileChannel，AsynchronousSocketChanne等实现，关于同步阻塞IO，同步非阻塞IO，异步阻塞IO和异步非阻塞IO在ppt的这页上下面备注有说明，有兴趣的可以深入了解下。Java NIO2中就实现了操作系统的异步非阻塞IO</p>
<p> 3.JDBC 4.1<br> 1）可以使用try-with-resources自动关闭Connection, ResultSet, 和 Statement资源对象<br> 2）RowSet 1.1：引入RowSetFactory接口和RowSetProvider类，可以创建JDBC driver支持的各种 row sets，这里的rowset实现其实就是将sql语句上的一些操作转为方法的操作，封装了一些功能。<br> 3）JDBC-ODBC驱动会在jdk8中删除 </p>
<p> 4.并发工具增强<br> 5.Networking增强<br> 6.Multithreaded Custom Class Loaders<br> 7.Security 增强<br> 8.Internationalization 增强 增加了对一些编码的支持和增加了一些显示方面的编码设置等<br> 9.jvm方面的一些特性增强。</p>
<p> JDK1.8的新特性</p>
<ol>
<li>接口的默认方法</li>
</ol>
<p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下</p>
<pre><code>interface Formula {
double calculate(int a);
default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
</code></pre><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用</p>
<pre><code>Formula formula=new Formula(){
   @Override
   public double calculate(int a){
       return sqrt(a*100);
   }
  }
</code></pre><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt(a*100)。<br>    在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他可复用代码的方法叫做mixin。新的Java 8的这个特性在编译器实现的角度上来说更接近Scala的trait</p>
<ol>
<li>Lambda表达式</li>
</ol>
<p>首先看看老版本的Java是如何排列字符串的</p>
<pre><code>List&lt;String&gt; names=Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
    Collection.sort(names,new Comparator&lt;String&gt;(){
    @Override
    public int compare(String a,String b){
         return b.compareTo(a);
    }
    });
</code></pre><p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列，通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p>
<p>在Java1.8中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式</p>
<pre><code>Collections.sort(names,(String a,String b)-&gt;{
    return b.compareTo(a);
});
</code></pre><p>代码变得更短更具有可读性，但是实际上还可以写的更短</p>
<pre><code>Collections.sort(names,(String a,String b)-&gt;b.compareTo(a));
</code></pre><p>java编译器可以自动推导出参数类型，所以你可以不用再写一次类型</p>
<ol>
<li>函数式接口<br>Lambda表达式是如何在java类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型，而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法，因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</li>
</ol>
<p>我们可以将lambda表达式当做任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的额接口添加@FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<pre><code>@FunctionalInterface
interface Converter&lt;F, T&gt; {
     T convert(F from);
}
Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);
</code></pre><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的</p>
<ol>
<li>方法与构造函数引用</li>
</ol>
<p>构造函数是如何使用:关键字来引用的，首先我们定义一个包含多个构造函数的简单类:</p>
<pre><code>class Person{
String firstName;
String lastName;
Person() {}

Person(String firstName, String lastName) {
   this.firstName = firstName;
   this.lastName = lastName;
}
}
</code></pre><p>接下来我们制定一个用来创建Person对象的对象工厂接口：</p>
<pre><code>interface PersonFactory&lt;P extends Person&gt; {
        P create(String firstName, String lastName);
     }
</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);
</code></pre><p>我们只需要使用Person：：new来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<ol>
<li>Lambda作用域</li>
</ol>
<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方法很相似，你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<ol>
<li>访问局部变量</li>
</ol>
<p>我们可以直接在lambda表达式中访问外层的局部变量：</p>
<pre><code>final int num = 1;
Converter&lt;Integer, String&gt; stringConverter =
(from) -&gt; String.valueOf(from + num); 
stringConverter.convert(2);
</code></pre><p>但是和匿名对象不同的是，这里的变量可以不用声明为final，该代码同样正确：</p>
<pre><code>int num = 1;
Converter&lt;Integer, String&gt; stringConverter =
(from) -&gt; String.valueOf(from + num); 
stringConverter.convert(2);
</code></pre><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译</p>
<pre><code>int num = 1;
Converter&lt;Integer, String&gt; stringConverter =
    (from) -&gt; String.valueOf(from + num);
num = 3;
</code></pre><p>在lambda表达式中试图修改num同样是不允许的。</p>
<ol>
<li>访问对象字段与静态变量</li>
</ol>
<p>和本地变量不同的是lambda内部对于实例的字段以及静态变量是既可读又可写。该行为和匿名对象是一致的：</p>
<pre><code>class Lambda4 {
static int outerStaticNum;
int outerNum; 


void testScopes() {
Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {
    outerNum = 23;
    return String.valueOf(from);
 };


Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {
    outerStaticNum = 72;
    return String.valueOf(from);
 };
 }
}
</code></pre><ol>
<li>访问接口的默认方法</li>
</ol>
<p>接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，一下代码将无法编译：</p>
<pre><code>Formula formula = (a) -&gt; sqrt( a * 100);
</code></pre><p>JDK1.8 API中包含了很多内建的函数式接口，在老Java中常用的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p>
<ol>
<li>Date API<br>Java 8在包java.time下包含了一组全新的日期API，新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分</li>
</ol>
<p>Clock时钟<br>  Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis()来获取当前的微妙数，某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<pre><code>Clock clock = Clock.systemDefaultZone();
long millis = clock.millis(); 
Instant instant = clock.instant();
Date legacyDate = Date.from(instant);
</code></pre><p>Timezones时区<br>  在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p>
<pre><code>System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids 

ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);
ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());
// ZoneRules[currentStandardOffset=+01:00]
</code></pre><p>LocalTime本地时间<br>  LocalTime定义了一个没有时区信息的时间，例如晚上10点，或者17:30:15。下面的例子使用前面的代码创建的市区创建了两个本地时间，之后比较时间并以小时和分钟为单位计算两个时间的时间差。</p>
<pre><code>LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2); 

System.out.println(now1.isBefore(now2)); // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween); // -3
System.out.println(minutesBetween);
</code></pre><p>LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>
<pre><code>LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late); // 23:59:59 

DateTimeFormatter germanFormatter =
  DateTimeFormatter
    .ofLocalizedTime(FormatStyle.SHORT)
    .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);
System.out.println(leetTime);
</code></pre><p>LocalDate本地日期<br>LocalDate表示了一个确切的日期，比如2014-03-11.该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象时不可变的，操作返回的总是一个新实例。</p>
<pre><code>LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2); 

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();

System.out.println(dayOfWeek); // FRIDAY
</code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p>
<pre><code>DateTimeFormatter germanFormatter =
DateTimeFormatter
    .ofLocalizedDate(FormatStyle.MEDIUM)
    .withLocale(Locale.GERMAN); 

LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);
System.out.println(xmas);
</code></pre><p>LocalDateTime本地日期时间<br>LocalDateTime同时表示了时间和日期，相当于前两节内容合并到一个对象上。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>
<pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); 

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek); // WEDNESDAY
Month month = sylvester.getMonth();
System.out.println(month); // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);
</code></pre><p>只要附加上时区信息，就可以将其转化为一个时间点Instantt对象，Instant时间点对象很容易的转换为老式的java.util.Date。</p>
<pre><code>Instant instant = sylvester
    .atZone(ZoneId.systemDefault())
    .toInstant(); 

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);
</code></pre><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<pre><code>DateTimeFormatter formatter =
DateTimeFormatter
    .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;); 

LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;,     formatter);
String string = formatter.format(parsed);
System.out.println(string);
</code></pre><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全。</p>
<ol>
<li>Annotation注解</li>
</ol>
<p>在java 8中支持多重注解了，先看个例子来理解一下是什么意思<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解</p>
<pre><code>@interface Hints{
    Hint[] value();
}

@Repeatable(Hints.class)
@interface Hint{
   String value();
}
</code></pre><p>Java 8允许我们把同一个类型的注解使用多次，只需要给注解标注一下@Repeatable即可</p>
<p>例1：使用包装类当容器来存多个注解（老方法）</p>
<pre><code>@Hints（{@Hint（&quot;hints&quot;）,@Hint(&quot;hints&quot;)}）
class Person{}
</code></pre><p>例2：使用多重注解（新方法）</p>
<pre><code>@Hint(&quot;hint1&quot;)
@Hint(&quot;hint2&quot;)
class Person{}
</code></pre><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p>
<pre><code>Hint hint=Person.class.getAnnotation(Hint.class);
System.out.println(hint);

Hints hints1=Person.class.getAnnotation(Hints.class);
System.out.println(hints2.length);    
</code></pre><h3 id="36-设计模式：单例、工厂、适配器、责任链、观察者等等"><a href="#36-设计模式：单例、工厂、适配器、责任链、观察者等等" class="headerlink" title="36. 设计模式：单例、工厂、适配器、责任链、观察者等等"></a>36. 设计模式：单例、工厂、适配器、责任链、观察者等等</h3><p>（1）单例<br>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题，如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以这应该是类设计者得责任，而不是类使用者的责任。从另一个角度来说，Singleton模式其实也是一种职责型模式，因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权利，同时它也肩负了行驶这种权利的职责。</p>
<blockquote>
<p>生活中的例子<br>美国总统的职位是Singleton，美国宪法规定了总统的选举，任期以及继任的顺序。这样，在任何时刻只能有一个现任的总统，无论现任总统的身份为何，其头衔“美利坚合众国总统”是访问这个职位的人的一个全局访问点。</p>
</blockquote>
<p>在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在，这样的模式有几个好处：</p>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li><p>有些类比如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了，所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>  public class Singleton{</p>
<pre><code>//持有私有静态实例，防止被引用，此处赋值为null，目的是为了实现延迟加载
private static Singleton instance=null;
//私有构造方法，防止被实例化
private Singleton(){
}
//静态工程方法，创建实例
public static Singleton getInstance(){
    if(instance==null){
         instance=new Singleton();
    }
    return instance;
}
public Object readReslove(){
    return instance;
}
</code></pre><p>  }</p>
</li>
</ul>
<p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决，我们首先会想到对getInstance方法加synchronized关键字，如下：</p>
<pre><code>public static synchronized Singleton getInstance(){
    if(isntance==null){
        instance=new Singleton();
    }
    return instance;
}
</code></pre><p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance（），都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以这个地方需要改进，我们改成下面这个：</p>
<pre><code>public static Singleton getInstance(){
      if(instance==null){
         synchronized(instance){
           if(instance==null){
              instance=new Singleton();
           }
         }
       }
}
</code></pre><p>似乎解决了之前提到的问题，将synchronized关键字加在内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建脆响和赋值操作时分开进行的，也就是说instance＝new Singleton()；语句时分两步进行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A，B两个线程为例：</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java面试（上）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/18/Java面试（上）/" class="article-date">
  	<time datetime="2017-01-18T02:49:55.000Z" itemprop="datePublished">2017-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/18/Java面试（上）/">Java面试（上）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-九种基本数据类型的大小，以及他们的封装类"><a href="#1-九种基本数据类型的大小，以及他们的封装类" class="headerlink" title="1.九种基本数据类型的大小，以及他们的封装类"></a>1.九种基本数据类型的大小，以及他们的封装类</h3><pre><code>byte（Byte）：1字节
short（Short）：2字节
int（Integer）：4字节
long（Long）：8字节
float（Float）：4字节
double（Double）：8字节
boolean（Boolean）
char（Character）：2字节
void（Void）
</code></pre><h3 id="2-Switch能否用string做参数？"><a href="#2-Switch能否用string做参数？" class="headerlink" title="2.Switch能否用string做参数？"></a>2.Switch能否用string做参数？</h3><p>char int byte short可以，java 7之后可以使用string做参数</p>
<h3 id="3-equals和-的区别"><a href="#3-equals和-的区别" class="headerlink" title="3.equals和==的区别"></a>3.equals和==的区别</h3><p>“==”是一个运算符，而equals是object里面的一个方法<br>对于基本类型，在比较大小的时候可以使用“==”，看两个元素是否相等。equals没有用武之地。<br>对于对象之间的比较，“==”是比较两个对象的内存地址是否相等，equals在object也是使用“==”运算符实现的，所以不重写equals方法的类使用是一样的，但是我们一般会在子类中重写他，比较两个对象的内容是否一样。</p>
<h3 id="4-Object有哪些公用方法？"><a href="#4-Object有哪些公用方法？" class="headerlink" title="4.Object有哪些公用方法？"></a>4.Object有哪些公用方法？</h3><p>Object是所有类的父类，任何类都默认继承Object。</p>
<p>1）clone：protect方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常</p>
<p>2）equals：在Object中与“==”是一样的，子类一般都重写该方法</p>
<p>3）hashcode：该方法用于哈希查找，重写equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p>4）getClass：final方法，获得运行时类型</p>
<p>5）wait：是当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(longtimeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生：<br>1.其他线程调用了该对象的notify方法<br>2.其他县城调用了该对象的notfyAll方法<br>3.其他县城调用了interrupt中断该线程<br>4.时间间隔到了<br>此时该县城就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常</p>
<p>6）notify：唤醒在该对象上等待的某个线程</p>
<p>7）notifyAll：唤醒在该对象上等待的所有县城</p>
<p>8）toString：转换成字符串，一般子类都有重写，否则打印句柄</p>
<h3 id="5-Object有哪些公用方法？"><a href="#5-Object有哪些公用方法？" class="headerlink" title="5.Object有哪些公用方法？"></a>5.Object有哪些公用方法？</h3><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用，软引用，弱引用和虚引用</p>
<p>1）强引用<br>以前我们使用的大部分引用时间上都是强引用，这是使用最普遍的引用，如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它，当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，是程序异常终止，也不会随意回收具有抢引用的对象来解决内存不足问题。</p>
<p>２）软引用（SoftReference）<br>如果一个对象只具有软引用，那就类似于可有可无的生活用品，如果内存空间足够垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用，软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>３）弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可无的生活用品，弱引用和软引用的区别在于：只有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收他的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用锁引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>４）虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收。<br>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会再回收对象的引用之前，把这个虚引用引入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么久可以在所引用的对象内存被回收之前采取必要的行动。</p>
<p>###６.Hashcode的作用。<br>hashCode的存在主要是用于查找的快捷性,如Hashtable,HashMap等,hashCode是用来在散列存储结构中确定对象的存储地址的</p>
<h3 id="7-ArrayList-LinkedList-Vector的区别"><a href="#7-ArrayList-LinkedList-Vector的区别" class="headerlink" title="7.ArrayList,LinkedList,Vector的区别"></a>7.ArrayList,LinkedList,Vector的区别</h3><p>ArrayList和Vector是采用数组方式存储数据,此数组元素大于实际存储的数据以便增加和插入元素,都允许直接序号索引元素,但是插入数据要涉及到数组元素移动等内存操作,所以索引数据块插入数据慢,vector由于使用了synchronized方法(线程安全)所以性能上比ArrayList要差,LinkedList使用双向链表实现存储,按序号索引数据需要进行向前或向后遍历,但是插入数据只需要记录本项的前后项即可,所以插入数据较快.</p>
<p>synchronized</p>
<p>java语音的关键字,当他用来修饰一个方法或者一个代码块的时候,能够保证在同一时刻最多只有一个线程执行该段代码.<br>1)当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时,一个时间内只能有一个线程得到执行,另一个线程必须等待当前线程执行完这个代码块后才能执行该代码块.<br>2)然而,当一个县城访问object的一个sunochronized(this)同步代码块时,另一个线程任然可以访问该object中的非synchronized(this)同步代码块.<br>3)尤其关键的是,当一个线程访问object的一个synchronized(this)同步代码块时,其他线程对object中所有其他synchronized(this)同步代码块的访问被阻塞.<br>4)第三个例子同样适用于其他同步代码块.也就是说,当一个线程访问object的一个synchronized(this)同步代码块时,他就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
<h3 id="8-String、StringBuffer与StringBuilder的区别。"><a href="#8-String、StringBuffer与StringBuilder的区别。" class="headerlink" title="8. String、StringBuffer与StringBuilder的区别。"></a>8. String、StringBuffer与StringBuilder的区别。</h3><p>String：字符串常量<br>StringBuffer：字符串变量（线程安全）<br>StringBuilder：字符串变量（非线程安全）</p>
<p>1）String类型是Java内的对象，是一个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，而且对象多了，Java的垃圾自动回收机制会开始工作，所以效率很低，建议在不断改变String对象的地方不要使用String类型</p>
<p>2）StringBuffer是个可变的对象，就是每次操作都是对对象本身进行操作，而不用生成新的对象，这样效率肯定就会有很大的提高，在大部分情况下StringBuffer的效率要比String类型高</p>
<p>3）StringBuilder与StringBuffer一样是个可变的字符串序列，提供与StringBuffer兼容的API，但是不能保证同步，用在字符串缓冲区被耽搁线程使用的情况，在单机非多线程的情况下使用StringBuilder会有比较好的效率，因为StringBuilder没有处理同步（Synchronized）问题。StringBuffer则会处理同步问题，如果StringBuilder会在多线程下被操作，则要改用StringBuffer，让对象自行管理同步问题。</p>
<p>注意点:<br>在使用StringBuffer时指定其容量，会比不指定其容量要快40%到50%左右，甚至比不指定容量的StringBuilder要快。所以在使用时最后指定其容量，对于性能有很大的提升。</p>
<h3 id="9-Map、Set、List、Queue、Stack的特点与用法。"><a href="#9-Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="9.Map、Set、List、Queue、Stack的特点与用法。"></a>9.Map、Set、List、Queue、Stack的特点与用法。</h3><p>Map：是键值对，键key是唯一不能重复的，一个键对应一个值，值可以重复<br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Map中可以将key和value单独抽取出来，其中KeySet()方法可以将所有的keys抽取成一个set，而Values()方法可以将map中所有的values抽取成一个集合</p>
<p>set：不包含重复元素的集合，set中最多包含一个null元素，只能用Iterator实现单项遍历，set中没有同步方法。</p>
<p>List：有序的可重复集合，可以再任意位置增加删除元素</p>
<p>Queue：遵从先进先出的原则，使用时尽量避免使用add（）和remove（）方法，而是使用offer（）来添加元素，使用poll（）来移除元素，他的有点事可以通过返回值来判断是否成功。LinkedList实现了Queue接口</p>
<p>stack：遵从后进先出的原则，Stack继承自vector。它通过五个操作对类Vector进行扩展，允许将向量视为堆栈，它提供了通常的push和pop操作，以及去堆栈顶点的peek()方法，测试堆栈是否为空的empty方法等。</p>
<h3 id="10-HashMap和HashTable的区别。"><a href="#10-HashMap和HashTable的区别。" class="headerlink" title="10.HashMap和HashTable的区别。"></a>10.HashMap和HashTable的区别。</h3><p>1）HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null（hashMap可以接受null的键（key）和值（value），而hashTable则不行）</p>
<p>2）HashMap是非synchronized，而hashtable是synchronized，这意味着hashtable是线程安全的，多个线程一个共享一个hashtable，而如果没有正确的同步的话，多个线程是不能共享hashMap的。</p>
<p>3）另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。</p>
<p>4）由于hashTable是线程安全的也是synchronized，所以在单线程环境下它比hashMap要慢。如果你不需要同步，只需要单一线程，那么使用hashmap性能要好过HashTable。</p>
<p>5）HashMap不能保证随着时间的推移map中的元素次序是不变的。</p>
<h3 id="11-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"><a href="#11-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。" class="headerlink" title="11.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"></a>11.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</h3><p>ConcurrentHashMap融合了hashmap和hashtable二者的优势。hashtable是做了同步的，hashmap未考虑同步，所以hashmap在单线程情况下效率较高，hashtable在多线程情况下，同步操作能保证程序执行的正确性。但是hashtable每次同步执行的时候都要锁住整个结构。</p>
<p>ConcurrentHashMap正式为了解决这个问题而诞生的。ConcurrentHashMap锁的当时是稍微细粒度的。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get，put，remove等常用操作只锁住当前需要用到的桶。</p>
<p>试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而而读线程几乎不受限制），并发性的提升是显而易见的。</p>
<p>更令人惊讶的是Concurrenthashmap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作的锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现的更明显些）。只有在求size等操作时才需要锁定这个表。</p>
<p>而在迭代时，ConcurrenthashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为弱一致迭代器。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据，更重要的，这保证了过个线程并发只想的连续性和扩展性，是性能提升的关键。</p>
<p>HashMap源码分析</p>
<p>1.关键属性</p>
<pre><code>transient Entry[] table；  //存储元素的实体数组
transient int size;  //存放元素的个数
int threshold;   //临界值  当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量
final float loadFactor; //加载因子
transient int modCount;//被修改的次数
</code></pre><p>其中loadFactor加载因子是表示Hash表中元素的填满程度<br>若加载因子越大填满的元素越多，好处是，空间利用率高了，但是冲突的机会加大了，链表长度会越来越长，查找效率降低。反之加载因子越小，填满的元素越少，好处是，冲突的机会减小了了，但空间浪费多了，表中的数据将过于稀疏（很多空间还没有用，就开始扩容了 ）<br>冲突的机会越大，查找的成本越高。</p>
<p>因此，必须在“冲突的机会”与“空间利用率”之间寻找一种平衡与折中，这种平衡与折中本质上是数据结构中有名的“时空”矛盾的平衡与折中。如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点，相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点，不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<p>2.构造方法</p>
<pre><code>public HashMap(int initialCapacity,float loadFactor){
//确保数字合法
if(initialCapacity&lt;0)
    throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;+initialCapacity);
if(initalCapacity&gt;MAXIMUM_CAPACITY)
   intitialCapacity=MAXIMUM_CAPACITY;
if(loadFactor&lt;=0 || Float.isNaN(loadFactor))
   throw new IllegalArgumentException(&quot;ILLegal load factor：&quot;+loadFactor);

//Find a power of 2&gt;=initialCapacity
int capacity=1; //初始容量
while（capacity&lt; initialCapacity）  //确保容量为2 的n次幂，使capacity为大于initialCapacity的最小的2的n次幂 
capacity&lt;&lt;=1;

this.loadFacotor=loadFactor;
threshold=(int)(capactiy*loadFactor);
table=new Entry[capacity];
init();
}

public HashMap(int initialCapacity){
   this(initialCapacity,DEFAULT_LOAD_FACTOR);
}

public HashMap(){
   this.loadFacotr=DEFAULT_LOAD_FACTOR;
   threshold=(int)(DERAULT_INITIAL_CAPACITY*DEFAULT_LOAD_DACTOR);
   table=new Entry[DEFAULT_INITIAL_CAPACITY];
      init();
}
</code></pre><p>我们可以看到在构造HashMap的时候如果我们制定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的，默认的初始容量为16，默认加载因子为0.75。</p>
<p>3.存储数据<br>下面看看HashMap的存储数据的过程是怎样的，首先看看HashMap的put方法：</p>
<pre><code>public V put(K key,V value){
    //若“key为null”，则将该键值对添加到table[0]中。
   if(key==null)
         return putForNullKey(value);
   //若“key不为null”，则计算该key的hash的值，然后在添加到该哈希值对应的链表中。
   int hash=hash(key.hashCode());
   //搜索指定hash值在对应table中的索引
   int i=indexFor(hash,table.length);
   //循环遍历Entry数组，若“该key”对应的键值对已经存在，则使用新的value取代旧的value。然后退出。
   for(Entry&lt;K,V&gt; e=table[i];e!=null;e=e.next){
        Object k;
        if(e.hash==hash&amp;&amp;((k=e.key)==key||key.eauqls(k))){ //如果key相同则覆盖并返回旧值
             V oldValue=e.value;
             e.value=value;
             e.recordAccess(this);
             return oldValue;
         }
    }
    //修改次数+1；
    modCount++;
    //将key-value添加到table[i]处
    addEntry(hash,key,value,i);
    return null;
}
</code></pre><p>上面程序中用到一个重要的内部接口：Map.Entry,每个Map.Entry其实就是一个key-value对。从上面程序中可以看出：当系统决定存储HashMap中的key-value对时，完全没有没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。这也说明了前面的结论：我们完全可以把Map集合中的value当成key的附属，当系统决定了key的存储位置之后，value随之保存在那里即可。</p>
<pre><code>private V putForNullKey(V value){
    for(Entry&lt;K,V&gt; e=table[0];e!=null;e=e.next){
       if(e.key==null){如果有key为null的对象存在，则覆盖掉
          V oldValue=e.value;
          e.value=value;
          e.recordAccesss(this);
          return oldValue;
             }
     }
     modCount++;
     addEntry(0,null,value,0); //如果键为null的话，则hash值为0
     return null；
 }
</code></pre><font color="red"><b>注意：如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0]</b></font>

<p>下面是计算hash码的函数：</p>
<pre><code>//计算hash值得方法，通过键的hashCode来计算
static int hash(int h){
   h^=(h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12);
   return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4);
}
</code></pre><p>得到hash码以后就会通过hash码去计算出应该存储在数组中的索引，计算索引的函数如下：</p>
<pre><code>static int indexFor(int h,int length){   //根据hash值和数组长度算出索引值
    return h &amp; (length-1); //这里不能随便算取，用hash&amp;（length-1）是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出
}
</code></pre><p>这个我们重点说下，我们一般对哈希表的散列很自然的会想到用hash值对length取模（即除法散列法），Hashtable也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;（length-1）的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p>
<p>接下来，我们分析下，为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样保证散列的均匀，同时也提升了效率，其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;（length-1）的最后一位可能为0也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列的到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同的hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀散列。</p>
<p>根据上面put方法的源代码可以看出，当程序试图将一个key-value对放入hashMap中，程序首先根据该key的hashCode（）返回值决定该Entry的存储位置：如果两个Entry的key的hashVode（）返回值相同，那他们的存储位置相同，如果两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有的Entry的value，但key不会覆盖，如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有的Entry形成Entry链，而且新添加的Entry位于Entry链的头部——具体说明继续看addEntry（）方法的说明。</p>
<pre><code>void addEntry(int hash ,K key ,V value,int bucketIndex){
    Entry&lt;K,V&gt; e=table[bucketIndex];  //如果要加入的位置有值，将该位置原先的值设置为新Entry的next，也就是新entry链表的下一个节点。
    table[bucketIndex]=new Entry&lt;&gt;(hash,key,value,e);
    if(size++&gt;=threshold)   //如果大于临界值就扩容
        resize(2*table.length);  //以2的倍数扩容
 }
</code></pre><p>参数bucketIndex及时indexFor函数计算出来的索引值，第二行代码是取得数组中索引为bucketIndex的Entry对象，第三行就是用hash，key，value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表，第四行和第五行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，hashMap扩容是扩为原来的两倍。</p>
<p>4.调整大小<br>resize（）方法如下：<br>重新调整HashMap的大小，newCapacity是调整后的单位</p>
<pre><code>void resize(int newCapacity){
   Entry[] oldTable=table;
   int oldCapacity=oldTalbe.length;
   if(oldCapacity==MAXIMUM_CAPACITY){
       threshold=Integer.MAX_VALUE;
       return ;
   }
   Entry[] new Table=new Entry[newCapacity];
   transfer(new Table);  //用来将原先table的元素全部移到newTable里面
   table=newTable； //再将newTable赋值给table
   threshold=（int）（newCapacity*loadFactor）；//重新计算临界值
}
</code></pre><p>新建一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将hashMap的全部元素添加到新的HashMap中，并重新计算新的数组中的索引位置。</p>
<p>当hashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定，所以为了提高查询的效率，就要对Hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在hashMap数组扩容后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值，也就是说，默认情况下，数组大小为16，那么当HashMap的元素个数超过16</em>0.75=12时候，就吧数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知Hashmap中元素的个数，那么预设元素的个数能够有效的提高hashMap的性能。</p>
<p>5.数据读取</p>
<pre><code>public V get(Object key){
    if(key==null)
       return getForNullKey();
    int hash=hash(key.hashCode());
    for(Entry&lt;K,V&gt; e=table[indexFor(hash,table.length)];e!=null;e.e.next){
           Object k;
           if(e.hash==hash&amp;&amp;((key=e.key)==key||key.equals(k)))
               return e.value;
           }
    return null;
}
</code></pre><p>有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<h3 id="12-TreeMap-HashMap-LindedHashMap的区别"><a href="#12-TreeMap-HashMap-LindedHashMap的区别" class="headerlink" title="12.TreeMap,HashMap,LindedHashMap的区别"></a>12.TreeMap,HashMap,LindedHashMap的区别</h3><p>Map主要用于存储键值对，根据键得到值，因此不允许键重复（重复了覆盖），但允许值重复。</p>
<p>HashMap是一个最常用的Map，他根据键的HashCode值存储数据，根据键可以直接获取他的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。Hashmap最多只允许一条记录的键为null；允许多条记录的值为null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致，如果需要同步，可以用collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrenthashMap.</p>
<p>Hashtable与HashMap类似，它继承自Dictionary类，不同的是，它不允许记录的键或者值为空，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候回比hashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkendHashmap慢，因为LinkedHashMap的遍历速度只和实际熟读有关，和容量无关，而Hashmap遍历的速度和他的容量有关。</p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值得升序排序，也可以制定排序的比较器，当用Iterator遍历TreeMap时，使得记录是排过序的。</p>
<p>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入，删除，定位元素，Hashmap是最好的选择。<br>TreeMap取出来的是排序后的键值对，但如果你要按自然顺序，或自定义排序遍历键，那么TreeMap会更好。<br>LindedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用linkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</p>
<h3 id="13-Collection包结构，与Collections的区别。"><a href="#13-Collection包结构，与Collections的区别。" class="headerlink" title="13.Collection包结构，与Collections的区别。"></a>13.Collection包结构，与Collections的区别。</h3><p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set </p>
<p>Collection是集合类的上级接口，子接口主要有Set 和List、Map。<br>Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="14-try-catch-finally，try里有return，finally还执行么？"><a href="#14-try-catch-finally，try里有return，finally还执行么？" class="headerlink" title="14. try catch finally，try里有return，finally还执行么？"></a>14. try catch finally，try里有return，finally还执行么？</h3><p>1.不管是否有出现异常，finally块中代码都会执行；<br>2.当try和catch中有return时，finally仍然会执行；<br>3.finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把药返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值）所以函数返回值是在finally执行前确定的；<br>4.finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的值</p>
<h3 id="15-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"><a href="#15-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。" class="headerlink" title="15.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"></a>15.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</h3><p><img src="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG" alt="java异常架构图"></p>
<p>1.Throwable<br>Throwable是java语言中所有错误或异常的超类。<br>Throwable包含两个子类：Error和Exception。它们通常用于指示放生了异常情况。<br>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStartTrace（）等接口用于捕获堆栈跟踪数据等信息。</p>
<p>2.Exception<br>Exception及其子类是Throwable的一种形式，它指出了合理的应用程序想要捕获的条件。</p>
<ol>
<li>RuntimeException<br>RuntimeException是那些可能在java虚拟机正常运行期间抛出的异常的超类。<br>编译器不会检查RuntimeException异常。例如，除数为0时，抛出ArithmeticException异常。<br>RuntimeException是ArithmeticException的超类，当代码发生除数为0的情况，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！<br>如果代码会产生RuntimException异常，则需要通过修改代码进行避免。</li>
</ol>
<p>4.Error<br>和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br>和RuntimeException一样， 编译器也不会检查Error。<br>Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>
<p>（1）运行时异常<br>定义：RuntimeException及其子类都被称为运行时异常。<br>特点：java编译器不会检查它，也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。<br>虽然java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。<br>如果产生运行时异常，则需要通过修改代码来进行避免。 </p>
<p>（2）被检查的异常<br>定义：Exception类本身，以及Exception的子类中除了“运行时异常”之外的其他子类都属于被检查异常。<br>特点：java编译器会检查它，此类异常，要门通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone（）接口去克隆一个对象，而该对象对应的类没有实现cloneable接口，就会抛出CloneNotSupportedException异常。<br>被检查异常通常都是可以恢复的。</p>
<p>（3）错误<br>定义：Error类及其子类<br>特点：和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足，约束失败，或是其他程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误。</p>
<p>OOM：<br>（1）OutOfMemoryError异常<br>除了程序计算器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。</p>
<p>java Heap溢出<br>一般的异常信息：java.lang.OutOfMemoryError:java heap sapcess</p>
<p>java堆用于存储对象实力，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<p>出现这种异常，一般手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数（-Xmx与-Xms）的设置是否适当</p>
<p>（2）虚拟机栈和本地方法溢出</p>
<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将会抛出StackOverflowError异常。<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>这里需要注意当栈的大小越大可分配的线程数就越少</p>
<p>（3）运行时常量池溢出</p>
<p>异常信息：java.lang.OutOfMemoryError:PermGen space</p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>
<p>（4）方法区溢出<br>方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。<br>异常信息：java.lang.OutOfMemoryError:PermGen space<br>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量class的应用中，要特别注意这点。</p>
<h3 id="16-java面向对象的三个特征与含义"><a href="#16-java面向对象的三个特征与含义" class="headerlink" title="16.java面向对象的三个特征与含义"></a>16.java面向对象的三个特征与含义</h3><p>对象是类的一个实例，有状态和行为。<br>类是一个末班，它描述一类对象的行为和状态</p>
<p>（1）封装性：将对象的状态信息尽可能的隐藏在对象内部，只保留有限的接口和方法与外界进行交互，从而避免了外界对对象内部属性的破坏。java中使用访问控制符来保护对类，变量，方法和构造方法的访问。</p>
<p>java中支持4种不同的访问权限、<br>默认的，也称为default，在同一包内可见，不使用任何修饰符。<br>私有的，以private修饰符制定，在同一类内可见<br>共有的，以public修饰符指定，对所有类可见。<br>受保护的，以protected修饰符指定，对同一包内的类和所有子类可见</p>
<p>（2）继承</p>
<p>java通过继承创建分等级层次的类，可以理解为一个对象从另一个对象获取属性的过程。类的继承是单一继承，也就是说，一个子类只能拥有一个父类。<br>子类拥有父类所有的成员变量，但对于父类private的成员变量却没有访问权限，这保障了父类的封装性</p>
<p>（3）多态</p>
<p>多态是同一个行为具有多个不同表现形式或形态的能力，多态性是对象多种表现形式的体现。</p>
<h3 id="17-Override和Overload的含义区别。"><a href="#17-Override和Overload的含义区别。" class="headerlink" title="17.Override和Overload的含义区别。"></a>17.Override和Overload的含义区别。</h3><p>方法的重写（Overriding）和重载（Overloading）是java多态性的不同表现。<br>重写（Overriding）是父类与子类之间多态性的一种表现，而重载（Overriding）是一个类中多态性的一种表现，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写（Overriding）。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被屏蔽了。如果在一个类中定义了多个同名的方法，他们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载（Overloading）。不能通过访问权限，返回类型，抛出的异常进行重载。</p>
<p>（1）Override特点<br>1&gt;覆盖的方法标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2&gt;覆盖的方法返回值必须和被覆盖的方法返回一致<br>3&gt;覆盖的方法所抛出的异常必须哟啊和被覆盖方法所抛出的异常一致，或者是其子类；<br>4&gt;方法被定义为final不能被重写<br>5&gt;对于继承来说，如果某一方法在父类中访问权限是private，那么久不能在子类对其进行重写覆盖，如果定义的话，也只是定义了一个新方法，而不会达到重写覆盖的效果。</p>
<p>（2）Overload特点<br>1&gt;在使用重载时只能通过不同的参数样式。例如不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一个方法内的几个参数类型必须不一致）<br>2&gt;不能通过访问权限，返回类型，抛出的异常进行重载<br>3&gt;方法的异常类型和数目不会对重载造成影响<br>4&gt;重载事件通常发生在一个类中，不同方法之间的现象<br>5&gt;存在于同一类中，但是只有虚方法和抽象方法才能被覆写</p>
<p>overload是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的多态机制。 是一种静态的绑定机制（在编译时已经知道具体执行的是哪个代码段）。   </p>
<p>override是覆盖。覆盖是一种动态绑定的多态机制。即在父类和子类中同名元素（如成员函数）有不同 的实现代码。执行的是哪个代码是根据运行时实际情况而定的。 </p>
<h3 id="18-Interface与abstract类的区别。"><a href="#18-Interface与abstract类的区别。" class="headerlink" title="18.Interface与abstract类的区别。"></a>18.Interface与abstract类的区别。</h3><p>(1)抽象类是不能被实例化的类，只能作为其他类继承的基类；<br>   接口则定义了实现某种服务的一般规范（Objective-C中将接口称为“协议”（protocol））,声明了必须的函数和常量，但不指定如何实现<br>(2)子类通过extends关键字来继承抽象类（且只能继承一个）<br>   类通过implenments关键字来实现接口（可以实现多个）<br>(3)在抽象类中定义的所有方法都必须在子类中实现；<br>   当类实现了接口后，接口中的所有方法都必须实现。如果实现类没有实现接口中的所有方法，则必须声明为抽象类。<br>(4)在抽象类中可以实现一些行为（实际上，抽象类可以完全实现，部分实现，根本不实现）<br>   在接口中只能定义方法，不能实现方法</p>
<p>抽象类和接口的选择问题：<br>1.如果要创建一个模型，这个模型将由一些紧密相关的对象采用，就可以使用抽象类，如果要创建由一些不相关对象采用的功能，就使用接口<br>2.如果必须从多个来源继承行为，就是用接口<br>3.如果知道所有类都会共享一个公共的行为实现，就是用抽象类，并在其中实现该行为。在接口中无法实现行为。</p>
<h3 id="19-Static-class-与non-static-class的区别。"><a href="#19-Static-class-与non-static-class的区别。" class="headerlink" title="19.Static class 与non static class的区别。"></a>19.Static class 与non static class的区别。</h3><p>静态类是指在一个类的内部，有定义了一个用static修饰的类，那静态类的功能又体现在哪里呢？可以用C中的结构体内嵌结构体来理解，其次需要了解两个概念：内部类和静态修饰符static。<br>A.首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类，所以没必要专门用一个Java文件存放这个类。<br>B.静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。这样静态内部类就可以理解了，他可以直接被用外部类名+内部类名 获得。</p>
<h3 id="20-java多态的实现原理"><a href="#20-java多态的实现原理" class="headerlink" title="20.java多态的实现原理"></a>20.java多态的实现原理</h3><p>（1）Java多态概述<br>多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用（invokevitual）和接口引用调用（invokeinterface）的实现则有所不同。</p>
<p>类引用调用的大致过程为：Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中的方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法，按照继承关系从下往上搜索。</p>
<p>![JVM运行时结构][2]</p>
<p>  从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量，成员变量，以及方法表。这个类型信息就存储在方法区。<br>  注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像java反射机制那样，通过class对象可以访问到该类的所有信息一样。<br>  【重点】<br>  方法表是实现动态调用的核心，上面讲过方法表存放在方法区中的类型信息，为了优化对象调用方法的速度，方法区的类型会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个想都是对应方法的指针。<br>  【扩展】<br>  方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。<br>  运行时常量池：它是方法区的一部分，Class文件中除了有类的版本，方法，字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。<br>  方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p>
<p>  （2）java的方法调用方式<br>  Java的方法调用有两类，动态方法调用与静态方法调用。<br>  静态方法调用时针对于类的静态方法调用，是静态绑定的，而动态方法调用需要有方法调用所作用的对象，是动态绑定。<br>  类调用（invlkestatic）是在编译时就已经确定好具体调用方法的情况。<br>  实例调用（invlkevitural）则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。<br>  JVM的方法调用指令有四个，分别是invokestatic，invokespecial，invokesvirtual和invlkeinterface。前两个是静态绑定，后两个是动态绑定。</p>
<p>  （3）方法表与方法调用<br>  如有类定义Person，Girl，Boy</p>
<pre><code> class Person{
     public String toString(){
         return &quot;I&apos;m a person&quot;;
     }
     public void eat(){}
     public void speak(){}
}

class Boy extends Person{
     public String toString(){
        return &quot;I&apos;m a boy&quot;;
    }
    public void speak(){}
    public void fight(){}
}

class Girl extends Person{
    public String toString(){
       return &quot;I&apos;m a girl&quot;;
    }
    public void speak(){}
    public void sing(){}
}
</code></pre><p>当这三个类被载入到Java虚拟机之后，方法区中就包含了各自的类的信息，Girl和Boy在方法区中的方法表可表示如下：<br><img src="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG" alt="方法表"></p>
<p>  可以看到，Girl和Boy的方法表包含继承自Object的方法，继承自直接父类的Person的方法及各自新定义的方法。注意方法表条目指向的具体买的方法地址，如Girl继承自Object的方法中，只有toString（）指向自己的实现（Girl的方法代码）其余皆指向Object的方法代码，其继承自Person的方法eat（）和speak（）分别指向Person的方法实现和本身的实现。<br>  如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。因此方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。<br>  Person或Object中的任意一个方法，在他们的方法表和其子类Girl和Boy的方法表中的位置（index）是一样的。这样JVM在调用实例方法只需要制定调用方法表中的第几个方法即可。<br>  如调用如下：</p>
<pre><code>class Party{
    void happHour(){
      Person girl =new Girl();
      girl.speak();
    }
}
</code></pre><p>当编译party类的时候，生成girl.speak()的方法调用假设为：<br>Invlkevitual #12<br>设该调用代码对应着girl.speak();#12是Party类的常量池的索引。JVM执行该调用指令的过程如下所示：</p>
<blockquote>
<p>1)在常量池中找到方法的直接引用<br>2)查看Person的方法表，得到speak方法在该方法表的偏移量（假设为15），这样就得到该方法的直接引用<br>3)根据this指针得到具体的对象（即girl所指向的位于堆中的对象）。<br>4)根据对象得到该对象对应的方法表，根据偏移量15查看有无重写（Override）该方法，如果重写，则可以直接调用（Girl的方法表的speak项指向自身的方法而非父类），如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是Person类）的方法表，同样按照这个偏移量15查看有无该方法。</p>
</blockquote>
<p>（4）接口调用<br>因为Java类是可以同时实现多个接口的，而当用接口调用否个方法的时候，情况就有所不同了。<br>java允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置可能不一样了</p>
<pre><code>interface IDance{
    void dance();
}

class Person{
   public String toString(){
      return &quot;I&apos;m a person&quot;;
   }
   public void eat(){}
   public void speak(){}
}
class Dancer extends Person implements IDance{
   public String toString(){
       return &quot;I&apos;m a dancer.&quot;;
   }
   public void dance(){}
}

class Snake implements IDance{
    public String toString(){
       return &quot;A snake.&quot;;
    }
    public void dance(){
    //snake dance
    }
}
</code></pre><p>可以看到由于接口的接入，继承自于接口IDance的方法dance()在类Dancer和Snake的方法表种的位置已经不一样了，我们无法仅根据偏移量来进行方法的调用。<br>Java对于接口方法的调用时采用搜索方法表的方式，如要在Dancer的方法表种找到dance()方法，必须搜索Dancer的整个方法表。<br>因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是满语接口方法的调用。</p>
<h3 id="21-实现多线程的两种方法，Thread和Runable"><a href="#21-实现多线程的两种方法，Thread和Runable" class="headerlink" title="21.实现多线程的两种方法，Thread和Runable"></a>21.实现多线程的两种方法，Thread和Runable</h3><p>线程的概念：线程（Thread）是指一个任务从头至尾的执行流，线程提供一个运行任务的机制，对于java而言，一个程序中可以并发的执行多个线程，这些线程可以在多处理器上面同时进行，当程序作为一个应用程序运行时，java解释器为main（）方法启动一个线程。</p>
<p>并行与并发</p>
<blockquote>
<p>并发：在单处理器系统中，多个线程共享CPU时间，而操作系统负责调度与分配资源给它们<br>并行：在多处理器系统中，多个处理器可以同时运行多个线程，这些线程在同一时间可以同时运行，而不同于并发，只能多个线程共享CPU时间，同一时间只能运行一个线程。</p>
</blockquote>
<p>线程的创建：<br>1）基础概念：java中每个任务就是一个可运行对象，为了创建任务，必须首先定义任务类，任务类必须实现Runable接口。而线程本质上讲就是便于任务执行的对象。一个线程的执行过程就是一个任务类中run（）方法的执行到结束。<br>2）通过Runnable接口创建线程：</p>
<blockquote>
<p>a.定义一个任务类实现Runnable接口，实现Runnable接口中的run（）方法（run（）方法告知系统线程该如何运行），run（）方法中定义具体的任务代码或处理逻辑。<br>b.定义了任务类后，为任务类创建一个任务对象<br>c.任务必须在线程中执行，创建一个Thread类的对象，将前面创建的实现了Runnable接口的任务类对象作为参数传递给Thread类的构造方法。<br>d.调用Thread类对象的start（）方法，启动一个线程，它会导致任务的run（）方法被执行，当run（）方法执行完毕，则线程就终止。</p>
</blockquote>
<pre><code>package com.muzeet.mutithread;

//每个任务都是Runnable接口的一个实例，任务是可运行对象，线程是便于任务执行的对象，必须创建任务类，重写run方法定义任务
public class ThreadDemo1 implements Runnable{
     private int countDown=10;
     @Override
     //重写run方法，定义任务
     public void run(){
        while(countDown-- &gt;0){
           System.out.println(&quot;$&quot;+Thread.currentThread().getName+&quot;(                &quot;+countDown+&quot;)&quot;);
        }
    }

    public static void main(String[] args){
         Runnable demo1=new ThreadDemo1();

         Thread thread1=new Thread(demo1);
         Thread thread2=new Thread(demo1);
         thread1.start();
         thread2.start();
         System.out.println(&quot;火箭发射倒计时:&quot;); 
    }
}
</code></pre><p>程序运行结果<br>火箭发射倒计时:</p>
<pre><code>    $Thread-0(9)      
$Thread-0(8)
    $Thread-0(7)
$Thread-0(6)
    $Thread-0(5)
$Thread-0(4)
    $Thread-0(3)
$Thread-0(2)
    $Thread-0(1)
$Thread-0(0)
</code></pre><p>同时运行两个任务对象</p>
<pre><code>public static void main(String[] args){
     Runnable demo1=new ThreadDemo1();
     Runnable demo2=new ThreadDemo2();
     Thread thread1=new Thread(demo1);
     Thread thread2=new Thread(demo2);

     thread1.start();
     thread2.start();
     System.out.println(&quot;火箭发射倒计时：&quot;);
 }
</code></pre><p>运行结果</p>
<pre><code>$Thread-0(9)
$Thread-0(8)
$Thread-0(7)
$Thread-0(6)
$Thread-1(9)
$Thread-0(5)
$Thread-1(8)
$Thread-0(4)
$Thread-1(7)
$Thread-0(3)
$Thread-1(6)
$Thread-1(5)
$Thread-0(2)
$Thread-1(4)
$Thread-1(3)
$Thread-1(2)
$Thread-1(1)
$Thread-1(0)
$Thread-0(1)
$Thread-0(0)
</code></pre><p>3）继承Thread类来创建线程：</p>
<blockquote>
<p>a.首先创建一个任务类extends Thread类，因为Thread实现了Runnable接口，所以自定的任务类也实现了Runnable接口，重写run（）方法，其中定义具体的任务代码或处理逻辑。<br>b.创建一个任务类对象，可以用Thread或者Runnable作为自定义的变量类型。<br>c.调用自定义对象的start（）方法，启动一个线程。</p>
</blockquote>
<p>示例代码</p>
<pre><code>package class ExtendFromThread extends Thread{
     private int countDown=10;
     @Override
     //重写run方法，定义任务
     public void run(){
         while(countDown-- &gt;0){
             System.out.println(&quot;$&quot;+this.getName+&quot;(                &quot;+countDown+&quot;)&quot;);
        }
    }
    //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止

   public static void main(String[] args){
     ExtendFormThread thread1=new ExtendFromThread();
     ExtendFormThread thread2=new ExtendFromThread();
     thread1.start();
     thread2.start();

     System.out.println(&quot;火箭发射倒计时：&quot;)；
   }
}
</code></pre><p>两种方法的比较</p>
<blockquote>
<p>首先分析两种方式的输出结果，同样是创建了两个线程，为什么结果不一样呢？<br>使用实现Runnable接口方式创建线程可以共享一个目标对象（TreadDemo1 tt=new TreadDemo();）,实现多个线程处理同一份资源。当第一个线程执行完任务后，countDown已经为0，所以第二个线程就不会输出。而继承Thread创建线程，new出了两个任务类对象，有各自的成员变量，相互之间不干扰。</p>
</blockquote>
<p>然后再看一段来自JDK的解释：</p>
<blockquote>
<p>Runnable接口应该由那些打算通过某一线程执行其实例的类来实现，类必须定义一个称为run的无参数方法。<br>设计该接口的目的是为了希望在活动时执行代码的对象提供一个公共协议。例如Thread类实现了Runnable。<br>此外，Runnable为非Thread子类的类提供了一种激活方式，通过实例化某个Thread实例并将自身作为运行目标，就可以运行实现Runnable的类。大多数情况下，如果只想重写run（）方法，而不重写其他Thread方法，那么应该使用Runnable接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类（推荐使用创建任务类，并实现Runnable几口，而不是继承Thread类）</p>
</blockquote>
<p>采用继承Thread类方式</p>
<blockquote>
<p>1)优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程,<br>2)缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p>
</blockquote>
<p>采用实现Runnable接口方式：</p>
<blockquote>
<p>1）优点：线程类只是实现了Runnable接口，还可以继承其他的类。在这种情况下，多个线程共享一个目标对象，所以非常适合多个祥泰线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread（）方法。</p>
</blockquote>
<h3 id="22-线程同步的方法：sychronized、lock、reentrantLock等"><a href="#22-线程同步的方法：sychronized、lock、reentrantLock等" class="headerlink" title="22. 线程同步的方法：sychronized、lock、reentrantLock等"></a>22. 线程同步的方法：sychronized、lock、reentrantLock等</h3><p>如果你想一个变量写值，而这个变量接下来可能会被另一个线程读取，或者你从一个变量读值，而它的值可能是前面由另一个线程写入的，此时你就必须使用同步</p>
<p>例子：</p>
<pre><code>package cn.outofmemory.locks;

public class LockDemo implements Runnable {
   private int counter = 0;

   public void run() {
      int loopTimes = 10000;
      while (loopTimes &gt; 0) {
          counter ++;                
          loopTimes --;
      }
   }

  public static void main(String[] args) throws InterruptedException {
     LockDemo demo = new LockDemo();

     Thread[] threads = new Thread[]{
            new Thread(demo), new Thread(demo),new Thread(demo), new Thread(demo),new Thread(demo)
    };


    for (Thread t : threads) {
        t.start();
    }

    for (Thread t : threads) {
        t.join();
    }

    System.out.println(&quot;demo&apos;s counter is &quot; + demo.counter);
}
</code></pre><p>}</p>
<p>这段代码中的LockDemo类实现了Runnable接口，在run方法中对其私有变量counter递加了10000次。在main方法中我们首先初始化了一个LockDemo对象，然后初始化了5个线程，这5个线程公用一个LockDemo的实例。然后我们一次启动这5个线程，然后通过join等待所有线程结束，最后输出demo实例的counter值来。<br>运行程序，得到这样一个输出结果：</p>
<pre><code>demo&apos;s counter is 44041
</code></pre><p>本来5个线程每个线程递加10000次，应该得到的结果是50000，而实际的结果是44041<br>如果你也运行此程序可能会得到不一样的结果，这取决于这5个线程造成了多少次冲突。</p>
<p>冲突的地方在于，他们公用了demo对象，同时对demo对象的成员变量counter做递加，也就是说冲突出现在对counter递加这一步上。<br>我们在这一步操作上加上synchronized关键字，让5个线程执行到对counter++这步代码时单独运行</p>
<p>synchronized在修饰代码块的时候需要一个reference对象作为锁的对象，在修饰方法的时候默认是当前对象作为锁的对象，在修饰类的时候默认是当前类的Class对象作为锁的对象。</p>
<p>修改后的run方法代码：</p>
<pre><code>public void run() {
    int loopTimes = 10000;
    while (loopTimes &gt; 0) {
        synchronized (this) {
            counter ++;                
        }
        loopTimes --;
    }
}
</code></pre><p>synchronized关键字是jvm虚拟机的关键字，在java.util.concurrent.locks命名空间中还有一个Lock接口，和Lock接口的实现类ReentrantLock（可重入锁）。ReentrantLock可以实现和synchronized关键字相同的功能，而且更为灵活，在极端的情况下性能会更好一些。</p>
<pre><code>private final Lock lock=new ReentrantLock();
public void run(){
    int loopTimes=10000;
    while(loopTimes&gt;0){
        try{
          lock.lock();
          counter ++;
        }finally{
           lock.unlock();
        }
        loopTime --;
    }
}
</code></pre><p>在LockDemo中添加了一个final的成员变量lock，它是一个ReentrantLock的实例。在run方法中，在counter++这行代码两边加上try…finally…语句，当线程执行到try块之后，首先通过lock.lock()获得锁，获得锁之后再执行counter++,最后在finally语句块中通过lock的unlock（）方法放锁。</p>
<p>synchronized获得内部锁存在一定的局限</p>
<blockquote>
<p>1.不能中断一个正在试图获得锁的线程<br>2.试图获得锁时不能像trylock那样设定超时时间<br>3.每个锁只有单一的条件，不能像condition那样设置多个</p>
</blockquote>
<p>synchronized关键字和可重入锁ReetrantLock选择的最佳实践：</p>
<blockquote>
<p>1.如果synchronized关键字适合程序，尽量使用它，可以减少代码出错的几率和代码数量<br>2.如果特别需要Lock/Condition结构提供的独有特性，才使用它们<br>3.许多情况下可以使用java.util.concurrent包中的一种机制，它会处理你所有的加锁情况</p>
</blockquote>
<h3 id="23-锁的等级：方法锁、对象锁、类锁"><a href="#23-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="23. 锁的等级：方法锁、对象锁、类锁"></a>23. 锁的等级：方法锁、对象锁、类锁</h3><p>方法锁（synchronized修饰方法时）</p>
<p>通过在方法声明中加入synchronized关键字来声明synchrozied方法。synchronized方法控制对类成员变量的访问：每个类实例对应一把锁，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行。否则所属线程阻塞，方法一旦执行，就独占该锁，只当从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为synchronized的成员函数至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<p>对象锁（synchronized修饰方法块或代码块）<br>当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法，或进入其同步区域时，就必须先获得对象锁，如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放（方法锁也是对象锁）</p>
<p>java的所有对象都包含一个互斥锁，这个锁由JVM自动获取和释放，线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待，synchronized方法正常返回或者异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的一个好处，方法抛出异常的时候，锁仍然可以由JVM来自动释放</p>
<p>对象锁的两种形式</p>
<pre><code>public class Test
{
// 对象锁：形式1(方法锁)
public synchronized void Method1()
{
    System.out.println(&quot;我是对象锁也是方法锁&quot;);
    try
    {
        Thread.sleep(500);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}


// 对象锁：形式2（代码块形式）
public void Method2()
{
    synchronized (this)
    {
        System.out.println(&quot;我是对象锁&quot;);
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }

}
</code></pre><p>类锁（synchronized修饰静态的方法或代码块）</p>
<p>由于一个class不论被实例化多少次，其中静态方法和静态变量在内存中都只有一份，所以一旦一个静态方法被声明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。</p>
<p>对象锁是用来控制实力方法之间的同步，类锁时用来控制静态方法（或静态变量互斥体）之间的同步</p>
<p>类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别。java类可能会有很多个对象，但是只有一个class对象，也就是说类的不同实例之间共享该类的Class对象，Class对象其实也仅仅是一个java对象，只不过有点特殊。由于每个java对象都有一个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。</p>
<pre><code>public class Test
{
// 类锁：形式1
public static synchronized void Method1()
{
    System.out.println(＂我是类锁一号＂);
    try
    {
        Thread.sleep(500);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }

}
// 类锁：形式2
public void Method２()
{
    synchronized (Test.class)
    {
        System.out.println(＂我是类锁二号＂);
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }

    }

}
</code></pre><h3 id="24-写出生产者消费者模式"><a href="#24-写出生产者消费者模式" class="headerlink" title="24.写出生产者消费者模式"></a>24.写出生产者消费者模式</h3><blockquote>
<p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述的是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品，解决生产者/消费者问题的方法可分为两类：（1）采用某种机制保护生产者和消费者之间的同步；（2）在 生产者和消费者之间建立一个管道。第一种方式有较高的效率，并且易于实现，代码的可控性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。</p>
</blockquote>
<p>1.wait()/notify()方法</p>
<p>wait()/notify()方法时基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样我们就可以为任何对象实现同步机制。</p>
<p>wait()方法：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等待状态，让其他线程执行<br>notify()方法：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。</p>
<pre><code>//实现缓冲区
 public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedList&lt;Object&gt; list=new LinkedList&lt;Object&gt;();   //仓库存储的载体

//生产num个产品
public void produce(int num){
    //同步代码段
    synchronized(list){
        //如果仓库容量不足
        while(list.size()+num&gt;MAX_SIZE){
            System.out.println(&quot;[要生产的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
            try
            {
                //由于条件不满足，生产阻塞
                list.wait();        
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            list.add(new Object());
        }
        System.out.println(&quot;[已经生产产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());
        list.notify();
    }
}
//消费num个产品
public void consume(int num){
    //同步代码段
    synchronized(list){
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                list.wait();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[已经消费产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());  

        list.notifyAll();  
    }
}
//  get/set方法
public LinkedList&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedList&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}


public class Producer extends Thread{
//每次生产的产品数量
private int num;
//所在放置的仓库
private Storage storage;
//构造函数设置仓库
public Producer(Storage storage){
    this.storage=storage;
}
public void run(){
    produce(num);
}

//调用仓库Storage的生产函数
public void produce(int num){

    storage.produce(num);
}
public int getNum(){
    return num;
}
public void setNum(int num){
    this.num=num;
}
public Storage getStorage(){
    return storage;
}
public void setStorage(){
    this.storage=storage;
}
}

public class Consumer extends Thread{
private int num;
private Storage storage;
public Consumer(Storage storage){
    this.storage=storage;
}
public void run(){
    consume(num);
}
public void consume(int num){
    storage.consume(num);
}
public int getNum(){
    return num;
}
public void setNum(int num){
    this.num=num;
}
public Storage getStorage(){
    return storage;
}
public void setStorage(Storage storage){
    this.storage=storage;
}
}
</code></pre><p>2.await()/signal()方法<br>在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步，锁定，线程池等，他们可以实现更细粒度的线程控制。await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和wait()/notify()相同，完全可以取代他们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象绑定，进而控制并发程序访问竞争资源的安全。</p>
<pre><code>//实现缓冲区
public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedList&lt;Object&gt; list=new LinkedList&lt;Object&gt;();   //仓库存储的载体

//锁
private final Lock lock=new ReentrantLock();

//仓库满的条件变量
private final Condition full=lock.newCondition();

//仓库空的条件变量
private final Condition empty=lock.newCondition();

//生产num个产品
public void produce(int num){
    //获得锁
    lock.lock();
        //如果仓库容量不足
        while(list.size()+num&gt;MAX_SIZE){
            System.out.println(&quot;[要生产的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
            try
            {
                //由于条件不满足，生产阻塞
                full.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            list.add(new Object());
        }
        System.out.println(&quot;[已经生产产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());

        //唤醒其他所有线程
        full.signalAll();
        empty.signalAll();
        //释放锁
        lock.unlock();

}
//消费num个产品
public void consume(int num){
    //获得锁
    lock.lock();
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                empty.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[已经消费产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());  

        //唤醒其他所有线程
        full.signalAll();
        empty.signalAll();

        //释放锁
        lock.unlock();

}
//  get/set方法
public LinkedList&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedList&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}
</code></pre><p>３. BlockingQueue阻塞队列方法<br>BlockingQueue是JDK5.0的新增内容，它是一个已经在内部实现了同步的队列，实现方式采用是我们第二种await()/signal()方法，它可以在生成对象时指定容量大小，它用于阻塞操作的是put()和take()方法</p>
<p>put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞<br>take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞</p>
<pre><code>public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedBlockingQueue&lt;Object&gt; list=new LinkedBlockingQueue&lt;Object&gt;(100);


//生产num个产品
public void produce(int num){
    //如果仓库剩余容量为0
    if(list.size()==MAX_SIZE){
        System.out.println(&quot;[库存量]:&quot; + MAX_SIZE + &quot;/t暂时不能执行生产任务!&quot;);  
    }

        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            try{
                //放入产品，自动阻塞
                list.put(new Object());
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }

        System.out.println(&quot;/t[现仓储量为]:&quot; + list.size());

    }

}
//消费num个产品
public void consume(int num){
    if(list.size()==0){
        System.out.println(&quot;[库存量]:0/t暂时不能执行生产任务!&quot;);
    }
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                empty.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[现仓储量为]:&quot; + list.size());  

        //唤醒其他所有线程


}
//  get/set方法
public LinkedBlockingQueue&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedBlockingQueue&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}
</code></pre><p>有时使用BlockingQueue可能会出现put()和System.out.println()输出不匹配的情况，这是由于它们之间没有同步造成的。当缓冲区已满，生产者在put()操作时，put()内部调用了await()方法，放弃了线程的执行，然后消费者线程执行，调用take()方法，take()内部调用了signal()方法，通知生产者线程可以执行，致使在消费者的println()还没运行的情况下生产者的println()先被执行，所以有了输出不匹配的情况。</p>
<h3 id="25-ThreadLocal的设计理念与作用"><a href="#25-ThreadLocal的设计理念与作用" class="headerlink" title="25.ThreadLocal的设计理念与作用"></a>25.ThreadLocal的设计理念与作用</h3><p>Jav中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，他们也无法访问到对方的ThreadLocal变量。</p>
<p>1）如何创建ThreadLocal变量</p>
<pre><code>private ThreadLocal myThreadLocal=new ThreadLocal();
</code></pre><p>通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，而且也不需要知道它是被哪个线程实例化，虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set（）方法设置的值，即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。</p>
<p>2）如何访问ThreadLocal变量</p>
<p>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值:</p>
<pre><code>myThreadLocal.set(&quot;A thread local value&quot;);
</code></pre><p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<pre><code>String threadLocalValue=(String) myThreadLocal.get();
</code></pre><p>get()方法返回一个Object对象，set（）方法需要传入一个Object类型的参数</p>
<p>3）为ThreadLocal制定泛型类型<br>我们可以创建一个制定泛型类型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值做强制类型转换了，下面展示了制定泛型类型的ThreadLocal例子：</p>
<pre><code>private ThreadLocal myThreadLocal=new ThreadLocal&amp;lt;String&amp;GT;();
</code></pre><p>现在我们只能往ThreadLocal对象中存入String类型的值了<br>并且我们从ThreadLocal中获取值得时候也不需要强制类型转换了</p>
<p>4）如何初始化ThreadLocal变量的值</p>
<p>由于在TrehadLocal对象中设置的值只能被设置这个值得线程访问到，线程无法在ThreadLocal对象上使用set()方法保存一个初始值，并且这个初始值能被所有线程访问到。<br>但是我们可以通过创建一个ThreadLocal的子类并且重写initialValue（）方法，来为一个ThreadLocal对象制定一个初始值，就像下面代码暂时那样：</p>
<pre><code>private ThreadLocal myThreadLocal =new ThreadLocal&amp;lt;String&amp;gt;(){
@Override
protect String initialValue(){
   return &quot;This is the initial value&quot;;
}
};
</code></pre><p>一个完整的ThreadLocal例子</p>
<pre><code>public class ThreadLocalExample{
    public static class MyRunnalbe implements Runnable{
        private ThreadLocal threadLocal=new ThreadLocal();

        @Override
        public void run(){
           threadLocal.set((int)(Math.random())*100D));
           try{
              Thread.sleep(2000);
           }
           catch (InterruptedException e){
           }
           System.out.println(threadLocal.get());
        }
    }
    public static void main(String[] args){
        MyRunnable shareRunnableInstance=new MyRunnable();
        Thread thread1=new Thread(shareRunnableInstance);
        Thread thread2=new Thread(shareRunnableInstance);
        thread1.start();
        thread2.start();
     }
     }

上面例子创建一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run（）方法，并且都在ThreadLocal实例上保存了不同的值，如果他们访问的不是ThreadLocal对象并且调用的set（）方法被同步了，则第二个线程会覆盖掉第一个线程设置的值，但是由于他们访问的是一个ThreadLocal对象，因此这两个线程都无法看到对方的值，也就是说他们取存的是两个不同的值。
</code></pre><h3 id="26-ThreadPool用法与优势"><a href="#26-ThreadPool用法与优势" class="headerlink" title="26. ThreadPool用法与优势"></a>26. ThreadPool用法与优势</h3><p>Java通过Executors提供四种线程池，分别为：<br>newCachedThreadPool创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程<br>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行<br>newSingleThreadExcutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行。</p>
<p>1）newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，示例的代码：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
for(int i=0;i&lt;10;i++){
     final int index=i;
     try{
         Thread.sleep(index*1000);
     }catch(InterruptedException e){
         e.printStackTrace();
     }
     cachedThreadPool.execute(new Runnable(){
         @Override
         public void run(){
             System.out.println(index);
         }
    });
}

线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程
</code></pre><p>2）newFixedThreadPool<br>创建一个定长线程池，可以控制线程最大并发数，超出的线程会在队列种等待，示例代码如下：</p>
<pre><code>ExecutorService fixedThreadPool=Executors.newFixedThreadPool(3);
for(int i=0;i&lt;10;i++){
    final int index=i;
    fixedThreadPool.execute(new Runnable(){
    @Ovrride
    public void run(){
       try{
          System.out.println(index);
          Thread.sleep(2000);
       }catch(InterruptedException e){
           e.printStackTrace();
       }
    }
});
}
</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。</p>
<p>3）newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行，延迟执行示例代码如下：</p>
<pre><code>ScheduledExecutorService scheduledThreadPool =Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable(){
@Override
public void run{
   System.out.println(&quot;delay 3 seconds&quot;);
}
},3,TimeUnit.SECONDS);
</code></pre><p>表示延迟3秒执行</p>
<p>定期执行示例代码如下：</p>
<pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
   @Override
   public void run(){
      System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
    }
},1,3,TimeUnit.SECONDS);
</code></pre><p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer更安全，功能更强大</p>
<p>4)newSingleThreadExecutor<br>创建一个单线程化得线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行，示例代码如下：</p>
<pre><code>ExecutorService singleThreadExecutor=Executor.newSingleThreadExecutor();
for(int i=0;i&lt;10;i++){
    final int index=i;
    singleThreadExecutor.execute(new Runnable(){
        @Override
        public void run(){
            try{
               System.out.println(index);
               Thread.sleep(2000);
            }catch(InterruptedException e){
               e.printStackTrace();
            }
        }
    });
}
</code></pre><p>结果依次输出，相当于顺序执行各个任务</p>
<p>线程池的优势<br>合理利用线程池能够带来三个好处</p>
<blockquote>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低县城创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用县城吃，必须对其原理了如指掌</li>
</ul>
</blockquote>
<h3 id="27-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"><a href="#27-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。" class="headerlink" title="27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"></a>27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</h3><p>java.util.concurrent包含许多线程安全，测试良好，高性能的并发构建块。通过提供一组可靠的，高性能并发构建块，开发人员可以提高并发类的线程安全，可伸缩性，性能，可读性和可靠性。</p>
<p>使用线程的理由：</p>
<blockquote>
<ul>
<li>更易响应的用户界面。事件驱动的GUI工具包（如AWT或Swing）使用单独的事件县城来处理GUI事件，从事件线程中调用通过GUI对象注册的事件监听器，然而，如果事件监听器将执行冗长的任务（如文档拼写检查），那么UI将出现冻结，因为事件线程直到冗长任务完毕之后才能处理其他事件。通过在单独县城中执行冗长操作，当执行冗长后台任务时，UI能继续响应。</li>
<li>使用多处理器。多处理器（MP）系统变得越来越简单，并且分布越来越广泛。因为调度的基本单位通常是线程，所以不管有多少处理器可用，一个县城的应用程序一次只能在一个线程上运行。在设计良好的程序中，通过更好地利用可用的计算机资源，多线程能够提高吞吐量和性能。</li>
<li>简化建模。有效使用线程能够使程序编写变得简单，并易于维护。通过合理使用线程，个别类可以避免一些调度的详细，交叉存取操作，异步IO和资源等待以及其他复杂问题。相反，他们能专注于域的要求，简化开发并改进可靠性。</li>
<li>异步或后台处理。服务器应用程序可以同时服务于许多远程客户机。如果应用程序从socket中读取数据，并且没有数据可以读取，那么对read()的调用将被阻塞，直到有数据可读，在单线程应用程序中，这意味着当某一个线程被阻塞时，不仅处理相应请求要延迟，并且处理所有请求也将延迟，然而，如果每个socket都有自己的IO线程，那么当一个线程被阻塞时，对其他并发请求行为没有影响。</li>
</ul>
</blockquote>
<p>线程安全</p>
<p>如果将这些类用于多线程环境中，虽然确保这些类的线程安全比较困难，但线程安全却是必需的。java.util.concurrent 规范进程的一个目标就是提供一组线程安全的、高性能的并发构建块，从而使开发人员能够减轻一些编写线程安全类的负担。<br>“如果可以从多个线程安全调用类，那么该类就是线程安全的”</p>
<p>要成为线程安全的类，首先它必须在单线程正确运行，如果正确实现了类，那么说明它符合规范，对该类的对象的任何顺序的操作（公共字段的读写，公共方法的调用）都不应该使对象出去无效状态，观察将处于无效状态的对象，或违反类的任何变量，前置条件或后置条件。<br>而且，要成为线程安全的类，在从多个线程访问时，它必须继续正确运行，而不管运行时环境执行那些线程的调度和交叉，且无需对部分调用代码执行任何其他同步。结果是对线程安全对象的操作将用于按固定的整体一致顺序出现所有线程。</p>
<p>如果没有线程之间的某种明确协调，比如锁定，运行时可以随意在需要时在多线程中交叉操作执行。</p>
<p>在 JDK 5.0 之前，确保线程安全的主要机制是 synchronized 原语。访问共享变量（那些可以由多个线程访问的变量）的线程必须使用同步来协调对共享变量的读写访问。java.util.concurrent 包提供了一些备用并发原语，以及一组不需要任何其他同步的线程安全实用程序类。</p>
<p>阻塞队列BlockingQueue<br>java.util.concurrent包里的BlockingQueue接口表示一个线程放入和提取实例的队列。BlockingQueue通常用于一个线程生产对象，而另一个消费这些对象的场景。<br>一个线程将会持续生产新对象并将其插入多队列中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列达到了其临界点，负责生产的线程将会在往里面插入新对象时发生阻塞，它会一个处于阻塞之中，知道负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从阻塞队列中拿出对象，如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p>
<p>可以访问到 BlockingQueue中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o)方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p>
<p>数组阻塞队列 ArrayBlockingQueue<br>ArrayBlockingQueue类实现了BlockingQueue接口。<br>ArrayBlockingQueue是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能存储无限多数量的元素，它有一个同一时间能够存储元素数量的上限。你可以再对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了。<br>ArrayBlockingQueue内部以FIFO（先进先出）的顺序对元素进行存储，队列中的头元素在所有元素之中时放入时间最久的那个，而尾元素则是最短的那个。</p>
<p>以下是在使用ArrayBlockingQueue的时候对其初始化的一个示例：</p>
<pre><code>BlockingQueue queue=new ArrayBlockingQueue(1024);
queue.put(&quot;1&quot;);
Object object=queue.take();
</code></pre><p>以下是使用了Java泛型的一个BlockingQueue示例。注意其中是如何对String元素放入和提取的：</p>
<pre><code>BlockingQueue&lt;String&gt; queue=new ArrayBlockingQueue&lt;String&gt;(1024);
queue.put(&quot;1&quot;);
String string=queue.take();
</code></pre><p>CountDownLatch<br>java.util.concurrent.CountDownLatch是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。CountDownlatch以一个给定的数量初始化。countDown（）每被调用一次，这一数量就减一。通过调用await（）方法之一，线程可以阻塞等待这一数量到达0；<br>以下是一个简单示例，Decrementer三次调用countDown()之后，等待中的Waiter才会从await（）调用中释放出来。</p>
<pre><code>CountDownLatch latch=new CountDownLatch(3);
Waiter waiter =new Waiter(latch);
Decrementer decrementer =new Decrementer(latch);

new Thread(waiter).start();
new Thread(decrementer).start();

Thread.sleep(4000);
public class Waiter implements Runnalbe{
     CountDownLatch latch=null;
     public Waiter (CountDownLatch latch){
         this.latch=latch;
     }
     public void run(){
         try{
            latch.await();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        System.out.println(&quot;Waiter Released&quot;);
    }
}
public class Decrementer implement Runnable{
     CountDownLatch latch=null;
     public Dcrementer(CountDownLatch latch){
          this.latch=latch;
     }
     public void run(){
        try{
            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();
            Thread.sleep(1000);
            this.latch.countDown();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Sparkstreming实时处理kafka里数据流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/16/Sparkstreming实时处理kafka里数据流/" class="article-date">
  	<time datetime="2017-01-16T08:17:41.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/Sparkstreming实时处理kafka里数据流/">Sparkstreming实时处理kafka里数据流</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>参考文章</p>
<p><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-spark-practice2/" target="_blank" rel="external">Spark实战，第二部分：使用Kafka和Spark Streaming构建实时数据处理系统</a></p>
<p><a href="http://spark.apache.org/docs/1.6.3/streaming-programming-guide.html" target="_blank" rel="external">Spark Streaming Programming Guide</a></p>
</blockquote>
<h2 id="关于Spark-Streaming"><a href="#关于Spark-Streaming" class="headerlink" title="关于Spark Streaming"></a>关于Spark Streaming</h2><p>Spark Streaming模块是对于Spark Core的一个扩展，目的是为了以提高吞吐量，并且容错的方式处理持续性的数据流。目前Spark支持的外部数据源有Flume,Kafka,Twitter,ZeroMQ,TCP Socket等。</p>
<p>Discretized Stream也叫DStream是Spark Streaming对于持续数据流的一种基本抽象，在内部实现上，DStream会被表示成一系列连续的RDD(弹性分布式数据集)，每一个RDD都代表一定时间间隔内到达的数据。所以在对DStream进行操作时，会被Spark Stream引擎转化成对底层RDD的操作。对Dstream的操作类型有：</p>
<blockquote>
<ul>
<li><p>Transformations:类似对于RDD的操作，Spark Streaming提供了一系列的转化操作去支持对DStream的修改，如map,union,filter,transform等</p>
</li>
<li><p>Window Operations:窗口操作支持通过设置窗口长度和滑动间隔的方式操作数据.常用的操作有reduceByWindow,reducerByKeyAndWindow,window等。</p>
</li>
<li><p>Output Operations:输出操作允许将DStream数据推送到其他外部系统或存储平台，如HDFS，Database等，类似于RDD的Action操作，Output操作也会实际上触发对DStreamde的转换操作。常用的操作有print,saveAsTestFiles,saveAsHadoopFiles,foreachRDD等</p>
</li>
</ul>
</blockquote>
<h2 id="创建Maven项目，编写POM"><a href="#创建Maven项目，编写POM" class="headerlink" title="创建Maven项目，编写POM"></a>创建Maven项目，编写POM</h2><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;cn.ly.kafka&lt;/groupId&gt;
&lt;artifactId&gt;kafkaTest&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

&lt;name&gt;kafkaTest&lt;/name&gt;
&lt;url&gt;http://maven.apache.org&lt;/url&gt;

&lt;properties&gt;
   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
 &lt;/properties&gt;

&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
    &lt;version&gt;0.10.1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-streaming-kafka_2.10 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
&lt;artifactId&gt;spark-streaming-kafka_2.11&lt;/artifactId&gt;
&lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-streaming_2.11 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
&lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt;
&lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;


&lt;dependency&gt;
   &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
   &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;
   &lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;!--  &lt;plugin&gt;
               &lt;artifactId&gt; maven-assembly-plugin &lt;/artifactId&gt;
               &lt;configuration&gt;
                    &lt;descriptorRefs&gt;
                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                    &lt;/descriptorRefs&gt;
                    &lt;archive&gt;
                         &lt;manifest&gt;
                              &lt;mainClass&gt;kafkaTest.ProducerTest&lt;/mainClass&gt;
                         &lt;/manifest&gt;
                    &lt;/archive&gt;
               &lt;/configuration&gt;
               &lt;executions&gt;
                    &lt;execution&gt;
                         &lt;id&gt;make-assembly&lt;/id&gt;
                         &lt;phase&gt;package&lt;/phase&gt;
                         &lt;goals&gt;
                              &lt;goal&gt;single&lt;/goal&gt;
                         &lt;/goals&gt;
                    &lt;/execution&gt;
               &lt;/executions&gt;
          &lt;/plugin&gt; --&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;/project&gt;
</code></pre><h2 id="编写Comsumer处理kafka里面的数据"><a href="#编写Comsumer处理kafka里面的数据" class="headerlink" title="编写Comsumer处理kafka里面的数据"></a>编写Comsumer处理kafka里面的数据</h2><pre><code>package kafkaTest;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.spark.*;
import org.apache.spark.api.java.function.*;
import org.apache.spark.streaming.Durations;
//import org.apache.spark.streaming.*;
import org.apache.spark.streaming.kafka.KafkaUtils;
import org.apache.spark.streaming.api.java.*;

import com.google.common.collect.Lists;

import scala.Tuple2;

public class KafkaStreamingWordCount {
    public static void main(String[] args) {
    //设置匹配模式，以空格分隔
    final Pattern SPACE = Pattern.compile(&quot; &quot;);
    //接收数据的地址和端口
    String zkQuorum = &quot;10.108.101.210:12181&quot;;
    //话题所在的组
    String group = &quot;1&quot;;
    //话题名称以“，”分隔
    String topics = &quot;user-behavior-topic&quot;;
    //每个话题的分片数
    int numThreads = 2;        
    SparkConf sparkConf = new SparkConf().setAppName(&quot;KafkaWordCount&quot;).setMaster(&quot;local[2]&quot;);
    JavaStreamingContext jssc = new JavaStreamingContext(sparkConf, Durations.seconds(5));
    //jssc.checkpoint(&quot;checkpoint&quot;);设置检查点‘
    //存放话题跟分片的映射关系
    Map&lt;String, Integer&gt; topicmap = new HashMap&lt;&gt;();
    String[] topicsArr = topics.split(&quot;,&quot;);
    int n = topicsArr.length;
    for(int i=0;i&lt;n;i++){
        topicmap.put(topicsArr[i], numThreads);
    }
    //从Kafka中获取数据转换成RDD
    JavaPairReceiverInputDStream&lt;String, String&gt; lines = KafkaUtils.createStream(jssc, zkQuorum, group, topicmap);
    //从话题中过滤所需数据
    JavaDStream&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;Tuple2&lt;String, String&gt;, String&gt;() {

        @Override
        public Iterable&lt;String&gt; call(Tuple2&lt;String, String&gt; arg0)
                throws Exception {
            return Lists.newArrayList(SPACE.split(arg0._2));
        }
    });
    //对其中的单词进行统计
    JavaPairDStream&lt;String, Integer&gt; wordCounts = words.mapToPair(
          new PairFunction&lt;String, String, Integer&gt;() {
            @Override
            public Tuple2&lt;String, Integer&gt; call(String s) {
              return new Tuple2&lt;String, Integer&gt;(s, 1);
            }
          }).reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer i1, Integer i2) {
              return i1 + i2;
            }
          });
    //打印结果
    wordCounts.print();
    jssc.start();
    jssc.awaitTermination();

}
}
</code></pre><p>利用maven项目生成可运行的jar包，放到服务器上运行报错。</p>
<p>Exception in thread “main” java.lang.NoSuchMethodError: scala.Predef$.ArrowAssoc(Ljava/lang/Object;)Ljava/lang/Object;</p>
<p>一开始怀疑是scala的版本问题，但是换了几个版本都没有用，后来尝试打包成普通的jar包，使用命令导入依赖的jar,发现可以运行了</p>
<p>打包：项目右键－&gt;run as－&gt;maven build-&gt;输入package（注释掉打包的pom字段）<br>命令：</p>
<pre><code>./spark-submit --class kafkaTest.KafkaStreamingWordCount --jars /usr/spark/spark-1.6.3-bin-hadoop2.6/lib/spark-streaming-kafka_2.10-1.6.3.jar,$SPARK_HOME/lib/spark-streaming-kafka-assembly_2.10-1.6.3.jar,$SPARK_HOME/lib/kafka_2.10-0.10.1.0,$SPARK_HOME/lib/kafka-client-0.10.1.0.jar,$SPARK_HOME/lib/google-collections-1.0.jar /home/kafkaTest-0.0.1-SNAPSHOT.jar
</code></pre><p>后来怀疑，之前打包成可执行的jar包不能运行是kafka版本的问题。</p>
<p>代码运行结果（结合上面的生产者）：</p>
<p><img src="http://7xruqa.com1.z0.glb.clouddn.com/spark%E5%A4%84%E7%90%86kafka.JPG" alt="运行结果"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java实现Kafka生产者" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/16/Java实现Kafka生产者/" class="article-date">
  	<time datetime="2017-01-16T03:54:19.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/Java实现Kafka生产者/">Java实现Kafka生产者</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>参考博客</p>
<p><a href="http://blog.csdn.net/m_signals/article/details/53206207" target="_blank" rel="external">kafka_2.11简单使用</a></p>
</blockquote>
<h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p>eclipse</p>
<p>new -&gt; Maven Projece -&gt; Group Id:org.apache.maven.archetypes ; Artifact Id:maven-archetype-quickstart -&gt;填写groupId,artifactId-&gt;finish</p>
<blockquote>
<ul>
<li><p>GroupId是项目组织唯一的标识符，实际对应Java的包结果，是main目录里java的目录结构</p>
</li>
<li><p>ArtifactId就是项目唯一的标识符，实际对应项目的名称，就是项目根目录的名称</p>
</li>
<li><p>一般GroupId就是填com.leafive.test这样子</p>
</li>
</ul>
</blockquote>
<h2 id="编写POM文件"><a href="#编写POM文件" class="headerlink" title="编写POM文件"></a>编写POM文件</h2><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;cn.ly.kafka&lt;/groupId&gt;
&lt;artifactId&gt;kafkaTest&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

&lt;name&gt;kafkaTest&lt;/name&gt;
&lt;url&gt;http://maven.apache.org&lt;/url&gt;

&lt;properties&gt;
   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
     &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
     &lt;version&gt;0.10.1.0&lt;/version&gt;
&lt;/dependency&gt;    
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
               &lt;artifactId&gt; maven-assembly-plugin &lt;/artifactId&gt;
               &lt;configuration&gt;
                    &lt;descriptorRefs&gt;
                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                    &lt;/descriptorRefs&gt;
                    &lt;archive&gt;
                         &lt;manifest&gt;
                              &lt;mainClass&gt;kafkaTest.ProducerTest&lt;/mainClass&gt;
                         &lt;/manifest&gt;
                    &lt;/archive&gt;
               &lt;/configuration&gt;
               &lt;executions&gt;
                    &lt;execution&gt;
                         &lt;id&gt;make-assembly&lt;/id&gt;
                         &lt;phase&gt;package&lt;/phase&gt;
                         &lt;goals&gt;
                              &lt;goal&gt;single&lt;/goal&gt;
                         &lt;/goals&gt;
                    &lt;/execution&gt;
               &lt;/executions&gt;
          &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>执行右键项目－&gt;Maven-&gt;Update Project</p>
<h2 id="编写生产者代码"><a href="#编写生产者代码" class="headerlink" title="编写生产者代码"></a>编写生产者代码</h2><pre><code>package kafkaTest;

import java.util.Properties;
import java.util.Random;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;

public class ProducerTest {

public static void main(String[] args) {
    Properties props = new Properties();
    props.put(&quot;bootstrap.servers&quot;, &quot;10.108.101.210:9092&quot;);
    props.put(&quot;acks&quot;, &quot;all&quot;);
    props.put(&quot;retries&quot;, 0);
    props.put(&quot;batch.size&quot;, 16384);
    props.put(&quot;linger.ms&quot;, 1);
    props.put(&quot;buffer.memory&quot;, 33554432);
    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

    Producer&lt;String,String&gt; producer = new KafkaProducer&lt;String,String&gt;(props);

    /*for (int i = 0; i &lt; 10; i++) {
        producer.send(new ProducerRecord&lt;String, String&gt;(&quot;user-behavior-topic&quot;, &quot;key-&quot;+i,&quot;value-&quot;+i)); 
        System.out.println(&quot;yifasong&quot;);

    }*/
    Random rand=new Random();
    int j=0;
    while(j&lt;30){
        int msgNum=rand.nextInt(3)+1;
        for(int i=0;i&lt;msgNum;i++){
            StringBuilder msg=new StringBuilder();
            msg.append(&quot;page&quot;+(rand.nextInt(100)+1));
            msg.append(&quot;|&quot;);
            msg.append(rand.nextInt(5)+1);
            msg.append(&quot;|&quot;);
            msg.append(rand.nextInt(5)+rand.nextFloat());
            msg.append(&quot;|&quot;);
            msg.append(rand.nextInt(2)-1);
            System.out.println(msg.toString());
            producer.send(new ProducerRecord&lt;String,String&gt;(&quot;user-behavior-topic&quot;, &quot;key-&quot;+i,msg.toString())); 
        }
        j++;
    }

    producer.close();


}

}
</code></pre><h2 id="项目打包运行"><a href="#项目打包运行" class="headerlink" title="项目打包运行"></a>项目打包运行</h2><p>项目右键－&gt;Run As－&gt;Maven clean</p>
<p>项目右键－&gt;Run As－&gt;Maven install</p>
<p>在项目目录下的target文件夹内得到打包好的jar包，上传到服务器</p>
<p>运行</p>
<pre><code>java -jar /home/kafkaTest-0.0.1-SNAPSHOT-jar-with-dependencies.jar
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Kafka集群搭建" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/14/Kafka集群搭建/" class="article-date">
  	<time datetime="2017-01-14T07:22:52.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/14/Kafka集群搭建/">Kafka集群搭建</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.cnblogs.com/luotianshuai/p/5206662.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="kafka初识"><a href="#kafka初识" class="headerlink" title="kafka初识"></a>kafka初识</h2><h3 id="1-Kafka使用背景"><a href="#1-Kafka使用背景" class="headerlink" title="1.Kafka使用背景"></a>1.Kafka使用背景</h3><p>在我们大量使用分布式数据库，分布式计算集群的时候，是否会遇到这样的一些问题</p>
<blockquote>
<ul>
<li>我们想分析下用户行为（pageviews），以便我们设计出更好的广告位</li>
<li>我想对用户的搜索关键词进行统计，分析出当前的流行趋势</li>
<li>有些数据，存储数据库浪费，直接存储硬盘效率又低</li>
</ul>
</blockquote>
<font color="red">这些场景都有一个共同点：数据是由上游模块产生，使用上游模块的数据计算，统计，分析，这个时候就可以使用消息系统，尤其是分布式消息系统。</font>

<h3 id="2-Kafka的定义"><a href="#2-Kafka的定义" class="headerlink" title="2.Kafka的定义"></a>2.Kafka的定义</h3><p><font color="blue">What is Kafka:</font>它是一个分布式消息系统，由linkedin使用scala编写，用作LinkedIn的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础，具有高水平扩展和高吞吐量。</p>
<blockquote>
<p>Zookeeper是一种在分布式系统中，被广泛用来作为：分布式状态管理，分布式协调管理，分布式配置管理和分布式锁服务的集群。kafka增加和减少服务器都会在Zookeeper节点上触发相应的事件kafka系统会捕获这些事件，进行新一轮的负载均衡。</p>
</blockquote>
<h2 id="Kafka相关概念"><a href="#Kafka相关概念" class="headerlink" title="Kafka相关概念"></a>Kafka相关概念</h2><h3 id="1-AMQP协议"><a href="#1-AMQP协议" class="headerlink" title="1.AMQP协议"></a>1.AMQP协议</h3><p>Advanced Message Queuing Protocol(高级消息队列协议)</p>
<blockquote>
<p>The Advanced Message Queuing Protocol（AMQP）：是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。</p>
</blockquote>
<h3 id="2-一些基本的概念"><a href="#2-一些基本的概念" class="headerlink" title="2.一些基本的概念"></a>2.一些基本的概念</h3><p>1.消费者（Consumer）:从消息队列中请求消息的客户端应用程序</p>
<p>2.生产者（Producer）:向broker发布消息的应用程序</p>
<p>3.AMQP服务器（broker）:用来接收生产者发送消息并将这些消息路由给服务器中的队列，便于kafka将生产者发送的数据，动态的添加到磁盘病给每一条消息一个偏移量，所以对于Kafka一个broker就是一个应用程序的示例，可以使用以上任何一种语言和kafka服务器进行通信（即可以编写自己的consumer从kafka集群订阅消息也可以自己写producer程序）</p>
<h3 id="3-Kafka架构"><a href="#3-Kafka架构" class="headerlink" title="3.Kafka架构"></a>3.Kafka架构</h3><blockquote>
<p>主题（topic）:一个主题类似新闻中的体育，娱乐，教育等分类概念，在实际工程中通常一个业务一个主题</p>
<p>分区（Partition）:一个Topic中的消息数据按照多个分区组织，分区时kafka消息队列组织的最小单位，一个分区可以看作是一个FIFO（First Input First Output的缩写，先入先出队列）的队列。</p>
</blockquote>
<p>kafka分区是提高kafka性能的关键所在，当你发现你的集群性能不高时，常用手段就是增加topic的分区，分区里面的消息是按照从新到老的顺序进行组织的，消费者从队列头订阅消息，生产者从队列尾添加消息。</p>
<p><img src="http://7xruqa.com1.z0.glb.clouddn.com/kafka%E5%B7%A5%E4%BD%9C%E5%9B%BE.JPG" alt=""></p>
<p>备份（Replication）:为了保证分布式可靠性，kafka0.8开始对每个分区的数据进行备份（不同的broker上）防止其中一个Broker宕机照成分区上的数据不可用。</p>
<h2 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h2><p>Kafka集群时把状态保存在Zookeeper中的，首先要搭建Zookeeper集群</p>
<h3 id="1-软件环境"><a href="#1-软件环境" class="headerlink" title="1.软件环境"></a>1.软件环境</h3><blockquote>
<p>10.108.101.210   master</p>
<p>10.108.103.137   slave1</p>
<p>10.108.100.59    slave2</p>
</blockquote>
<p>1.linux服务器一台，三台，五台（2*n＋1）Zookeeper集群的宫缩时超过半数才能对外提供服务，3台中超过两台超过半数，允许1台挂掉，是否可以用偶数，其实没必要。</p>
<p>2.Java jdk1.8 zookeeper时用java写的所以他的需要Java环境，java时运行在java虚拟机上的</p>
<p>3.Zookeeper的稳定版</p>
<h3 id="2-配置-amp-安装zookeeper"><a href="#2-配置-amp-安装zookeeper" class="headerlink" title="2.配置&amp;安装zookeeper"></a>2.配置&amp;安装zookeeper</h3><h4 id="1-安装Jdk"><a href="#1-安装Jdk" class="headerlink" title="1.安装Jdk"></a>1.安装Jdk</h4><h4 id="2-下载Zookeeper"><a href="#2-下载Zookeeper" class="headerlink" title="2.下载Zookeeper"></a>2.下载Zookeeper</h4><pre><code>＃统一放在/opt下面
＃首先创建Zookeeper项目目录
mkdir zookeeper  #项目目录
mkdir zkdata  #存放快照日志
mkdir zkdatalog  #存放事务日志
</code></pre><p>下载Zookeeper</p>
<pre><code>＃下载软件
cd /opt/zookeeper
wget http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz
#解压软件
tar -zxvf zookeeper-3.4.6.tar.gz
</code></pre><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><p>进入到解压好的目录里面的conf目录中，查看</p>
<pre><code>＃进入conf目录
/opt/zookeeper/zookeeper-3.4.6/conf
#查看 ll
-rw-rw-r--. 1 1001 1001  535 8月  23 15:39 configuration.xsl
-rw-rw-r--. 1 1001 1001 2161 8月  23 15:39 log4j.properties
-rw-r--r--. 1 root root 1013 1月  15 2017 zoo.cfg
-rw-rw-r--. 1 1001 1001  922 8月  23 15:39 zoo_sample.cfg
</code></pre><p>zoo_sample.cfg 这个文件是官方给我们的zookeeper的样板文件，给他复制一份命名为zoo.cfg，zoo.cfg是官方指定的文件命名规则</p>
<p>3台服务器的配置文件</p>
<pre><code># The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial 
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just 
# example sakes.
dataDir=/home/zookeeper-3.4.9/data
# the port at which the clients will connect
clientPort=12181
server.1=master:2888:3888
server.2=slave1:2888:3888
server.3=slave2:2888:3888
</code></pre><p>配置文件解释</p>
<pre><code>＃tickTime
这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳
＃initLimit
这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数，当已经超过5个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败，总的时间长度就是5*2000=10秒
＃syncLimit
这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个tickTime的时间长度，总的时间长度就是5*2000=10秒
＃dataDir
快照日志的存储路径
＃dataLogDir
事务日志的存储路径，如果不配置这个那么事务日志会默认存储到dataDir制定的目录，这样会严重影响zk的性能，当zk的吞吐量较大的时候，产生的事务日志，快照日志太多
＃clientPort
这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的请求访问，修改他的端口改大点
</code></pre><p>创建myid文件</p>
<pre><code>#server1
echo &quot;1&quot; &gt; /home/zookeeper-3.4.6/data/myid
#server2
echo &quot;2&quot; &gt; /home/zookeeper-3.4.6/data/myid
#server3
echo &quot;3&quot; &gt; /home/zookeeper-3.4.6/data/myid
</code></pre><h3 id="4-重要配置说明"><a href="#4-重要配置说明" class="headerlink" title="4.重要配置说明"></a>4.重要配置说明</h3><p>1.myid文件和server.myid在快照目录下存放的标识本台服务器的文件，他时整个zk集群用来发现彼此的一个重要标识</p>
<p>2.zoo.cfg文件时zookeeper配置文件在conf目录里</p>
<p>3.log4j.properties文件是zk的日志输出文件，在conf目录里用java写的程序基本上有个共同点日志都用log4j来进行管理</p>
<p>4.zkServer.sh：主要管理程序文件  zkEnv.sh：是zookeeper集群启动时配置环境变量的文件</p>
<p>5.Zookeeper server not remove old snapshots and log files when using the default configuration(see autopurge below),this is the responsibility of the operator zookeeper不会主动的清除旧的快照和日志文件，这个是操作者的责任</p>
<h3 id="5-启动服务并查看"><a href="#5-启动服务并查看" class="headerlink" title="5.启动服务并查看"></a>5.启动服务并查看</h3><p>1.启动服务</p>
<pre><code>#进入到zookeeper的bin目录下
cd /opt/zookeeper/zookeeper-3.4.6/bin
#启动服务（三台机子都需要操作）
./zkServer.sh start
</code></pre><p>2.检查服务状态</p>
<pre><code>#检查服务器状态
./zkServer.sh status
</code></pre><p>通过status就能看到状态</p>
<pre><code>./zkServer.sh status
JMX enabled by default
Using config:/opt/zookeeper-3.4.6/bin/../conf/zoo.cfg  #配置文件
Mode:follower  ＃他是否为领导
</code></pre><p>zk集群一般只有一个leader,多个follower，主一般是相应客户端的读写请求，而主从同步数据，当主挂掉之后就会从follower里投票选举一个leader出来</p>
<p>可以用jps查看zk的进程，这个zk的整个工程的main</p>
<pre><code>#执行命令jps
20348 Jps
4233  QuorumPeerMain
</code></pre><h2 id="Kafka集群搭建"><a href="#Kafka集群搭建" class="headerlink" title="Kafka集群搭建"></a>Kafka集群搭建</h2><h3 id="1-软件环境-1"><a href="#1-软件环境-1" class="headerlink" title="1.软件环境"></a>1.软件环境</h3><blockquote>
<ul>
<li>linux一台或多台，大于等于2</li>
<li>已经搭建好的zookeeper集群</li>
<li>软件版本kafka_2.11-0.10.1.0.tgz</li>
</ul>
</blockquote>
<h3 id="2-创建目录并下载安装软件"><a href="#2-创建目录并下载安装软件" class="headerlink" title="2.创建目录并下载安装软件"></a>2.创建目录并下载安装软件</h3><pre><code>#创建目录
cd /opt/
mkdir kafka
cd kafka
mkdir kafkalogs ＃创建kafka消息目录，主要存放kafka消息

＃下载软件
wget http://apache.opencas.org/kafka/0.10.1.0/kafka_2.11-0.10.1.0.tgz

＃解压软件
tar -zxvf kafka_2.11-0.10.1.0.tgz
</code></pre><h3 id="3-修改配置文件-1"><a href="#3-修改配置文件-1" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><p>进入到config目录</p>
<pre><code>cd /opt/kafka/kafka_2.11-0.10.1.0/config/
</code></pre><p>主要关注：server.properties这个文件即可，我们可以发现在目录下：有很多文件，这个可以发现有Zookeeper文件，我们可以根据Kafka内带的zk集群来启动，但是建议使用独立的zk集群</p>
<p>实际的修改项为：</p>
<pre><code>#broker.id=1   每台服务器的broker.id都不相同

#hostname
listeners=PLAINTEXT://master:9092

log.dirs=/opt/kafka_2.11-0.10.1.0/kafkalogs/

#在log.retention.hours=168 下面新增下面三项
message.max.byte=5242880
default.replication.factor=2
replica.fetch.max.bytes=5242880

#设置zookeeper的连接端口
zookeeper.connect=master:12181,slave1:12181,slave2:12181
</code></pre><h3 id="4-启动Kafka集群并测试"><a href="#4-启动Kafka集群并测试" class="headerlink" title="4.启动Kafka集群并测试"></a>4.启动Kafka集群并测试</h3><h4 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1.启动服务"></a>1.启动服务</h4><pre><code>＃从后台启动kafka集群（3台都需要启动）
cd /opt/kafka/kafka_2.11_0.10.1.0/bin   ＃进入到kafka的bin目录
./kafka-server-start.sh -daemon ../config/server.properties
</code></pre><h4 id="2-检查服务是否启动"><a href="#2-检查服务是否启动" class="headerlink" title="2.检查服务是否启动"></a>2.检查服务是否启动</h4><pre><code>#执行命令jps
20348  Jps
4233   QuorumPeerMain
18991  Kafka
</code></pre><h4 id="3-创建Topic来验证是否创建成功"><a href="#3-创建Topic来验证是否创建成功" class="headerlink" title="3.创建Topic来验证是否创建成功"></a>3.创建Topic来验证是否创建成功</h4><p>更多请看官方文档：<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">http://kafka.apache.org/documentation.html</a></p>
<pre><code>＃创建topic
./kafka－topics.sh --create -zookeeper master:12181 --replication-facotor 1 --replications 1 --topic test

＃解释
--replication-facotor 1 #复制两份
--partitions 1 ＃创建1个分区
--topic 主题为test

＃在一台服务器上创建一个发布者
./kafka-console-producer.sh --broker-list master:9092 --topic test

＃在一台服务器上穿件一个订阅则

./kafka-console-consumer.sh --zookeeper localhost:12181 --topic test --from-beginning

＃查看topic
./kafka-topics.sh --list --zookeeper master:12181
</code></pre><p>测试（在发布者那里发布消息看看订阅者那里是否能正常收到）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hadoop2-6-spark1-6-3分布式计算框架的搭建" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/13/hadoop2-6-spark1-6-3分布式计算框架的搭建/" class="article-date">
  	<time datetime="2017-01-13T02:29:25.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/hadoop2-6-spark1-6-3分布式计算框架的搭建/">hadoop2.6+spark1.6.3分布式计算框架的搭建</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="软硬件设备及安装前的环境搭建"><a href="#软硬件设备及安装前的环境搭建" class="headerlink" title="软硬件设备及安装前的环境搭建"></a>软硬件设备及安装前的环境搭建</h2><blockquote>
<p>操作系统：centos 6.7</p>
<p>软件版本：hadoop－2.6.0 ， spark－1.6.3 ， jdk1.8.0_111 ,scala-2.11.6</p>
<p>集群架构 ：包括三个节点，1个master，2个slave,节点之间局域网连接，可以互相ping通，节点IP地址分布如下:</p>
<pre><code>master   10.108.101.210
slave1   10.108.103.137
slave2   10.108.100.59
</code></pre></blockquote>
<h3 id="1-jdk-1-8-0-111安装"><a href="#1-jdk-1-8-0-111安装" class="headerlink" title="1.jdk-1.8.0_111安装"></a>1.jdk-1.8.0_111安装</h3><p>官网下载最新的的jdk tar.gz到/home目录下，在usr目录下建立java安装目录，解压</p>
<pre><code>cd /usr
mkdir java
tar zxvf /home/jdk-8u111-linux-x64.tar.gz -C /usr/java/
</code></pre><p>得到文件夹 jdk1.8.0_111</p>
<p>安装完毕为他建立一个链接以节省目录长度</p>
<pre><code>ln -s /usr/java/jdk1.8.0_111/ /usr/jdk
</code></pre><p>编辑配置文件，配置环境变量</p>
<pre><code>JAVA_HOME=/usr/jdk
CLASSPATH=.:$JAVA_HOME/lib/
PATH=$PATH:$JAVA_HOME/bin
export PATH JAVA_HOME CLASSPATH
</code></pre><p>重启机器或执行命令：source /etc/profile</p>
<p>查看安装情况： java －version </p>
<pre><code>java version &quot;1.8.0_111&quot;
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)
</code></pre><p>卸载本机jdk</p>
<blockquote>
<p>rpm -qa|grep jdk</p>
<p>yum -y remove java-1.7.0-openjdk</p>
</blockquote>
<h3 id="2-修改-etc-hosts"><a href="#2-修改-etc-hosts" class="headerlink" title="2.修改/etc/hosts"></a>2.修改/etc/hosts</h3><p>追加</p>
<pre><code>10.108.101.210   master
10.108.103.137   slave1
10.108.100.59    slave2
</code></pre><h3 id="3-配置ssh，实现免密码登陆"><a href="#3-配置ssh，实现免密码登陆" class="headerlink" title="3.配置ssh，实现免密码登陆"></a>3.配置ssh，实现免密码登陆</h3><p>在所用主机上新建hadoop用户</p>
<pre><code>#useradd hadoop
#passwod hadoop
</code></pre><p>关闭所有主机的防火墙</p>
<pre><code>service iptables stop
</code></pre><p>切换至hadoop用户</p>
<pre><code>su hadoop
</code></pre><p>在三台机子上执行,用hadoop登陆系统，进入个人主目录 /home/hadoop</p>
<pre><code>ssh-keygen -t rsa -P &apos;&apos;  //设置ssh的密钥和密钥存放路径，路径为～/.ssh下
</code></pre><p>以rsa算法，生成公钥，私钥，－P ‘’ 表示是空密码，该命令执行完成后，会在个人目录下生产.ssh目录，里面会有两个文件，id_rsa(私钥)和id_rsa(公钥)，该目录为隐藏目录，可用一下目录查看</p>
<pre><code>ls -lah
</code></pre><p>在master上将公钥放到authrozied_keys里</p>
<pre><code>sudo cat id_rsa.pub &gt;&gt; authorized_keys
chmod 600 authorized_keys
</code></pre><p>用scp将公钥文件拷贝到master机器上</p>
<pre><code>slave1: scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_01.pub
slave2: scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_02.pub
</code></pre><p>执行后，在master机器上，查看/home/hadoop目录，里面会有id_rsa_01和id_rsa_02.pub两个文件，然后再master机器上倒入这两个公钥</p>
<pre><code>cat id_rsa_01.pub &gt;&gt; .ssh/authorized_keys
cat id_rsa_02.pub &gt;&gt; .ssh/authorized_keys
</code></pre><p>将master上的公钥，复制到其他机器上，在master机器执行一下命令</p>
<pre><code>scp .ssh/authorized_keys hadoop@slave1:/home/hadoop/.ssh/authorized_keys
scp .ssh/authorized_keys hadoop@slave2:/home/hadoop/.ssh/authorized_keys
</code></pre><p>修改三台机子authorized_keys权限</p>
<pre><code>chmod 644 authorized_keys
</code></pre><p>测试是否成功：在任意一台机子上ssh hadoop@slave1不用密码直接进入系统，这就表示成功了。</p>
<p>如果hadoop用户使用不了sudo指令：</p>
<pre><code>vi /etc/sudoers
hadoop  ALL=(root)   NOPASSWD:ALL   //在root  ALL=(ALL)  ALL后添加这一句
</code></pre><h2 id="hadoop上传安装与配置"><a href="#hadoop上传安装与配置" class="headerlink" title="hadoop上传安装与配置"></a>hadoop上传安装与配置</h2><h3 id="1-下载解压hadoop"><a href="#1-下载解压hadoop" class="headerlink" title="1.下载解压hadoop"></a>1.下载解压hadoop</h3><p>把hadoop上传到服务器并解压到/usr/hadoop目录中</p>
<pre><code>tar zxvf hadoop-2.6.0.tar.gz -C /usr/hadoop
</code></pre><p>切换到/usr/hadoop目录下，修改hadoop-2.6.0的所有者</p>
<pre><code>chown -R hadoop.hadoop hadoop-2.6.0
</code></pre><h3 id="2-配置hadoop环境变量"><a href="#2-配置hadoop环境变量" class="headerlink" title="2.配置hadoop环境变量"></a>2.配置hadoop环境变量</h3><p>vi /etc/profile 配置环境变量</p>
<pre><code>HADOOP_HOME=/usr/hadoop/hadoop-2.6.0
export HADOOP_INSTALL=$HADOOP_HOME
export HADOOP_MAPRED_HOME=$HADOOP_HOME
export HADOOP_COMMON_HOME=$HADOOP_HOME
export HADOOP_HDFS_HOME=$HADOOP_HOME
export YARN_HOME=$HADOOP_HOME
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native
export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin
</code></pre><h3 id="3-hadoop配置"><a href="#3-hadoop配置" class="headerlink" title="3.hadoop配置"></a>3.hadoop配置</h3><p>位置：$HADOOP_HOME/etc/hadoop</p>
<h4 id="1-hadoop-env-sh和yarn-env-sh-加入"><a href="#1-hadoop-env-sh和yarn-env-sh-加入" class="headerlink" title="1.hadoop-env.sh和yarn-env.sh 加入"></a>1.hadoop-env.sh和yarn-env.sh 加入</h4><pre><code>export JAVA_HOME=/usr/jdk
</code></pre><h4 id="2-core-site-xml"><a href="#2-core-site-xml" class="headerlink" title="2.core-site.xml"></a>2.core-site.xml</h4><pre><code>&lt;configuration&gt;
&lt;property&gt;
&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
&lt;value&gt;file:/usr/hadoop/hadoop-2.6.0/tmp&lt;/value&gt;
&lt;description&gt;Abase for other temporary directories.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;fs.default.name&lt;/name&gt;
 &lt;value&gt;hdfs://master:9000&lt;/value&gt;
&lt;/property&gt;

&lt;/configuration&gt;
</code></pre><p>注意：/home/hadoop/tmp，这个文件要手动提前创建好;9000端口要开放，否则会出现hadoop正常启动，但看不到datanode使用的情况</p>
<h4 id="3-hdfs-site-xml"><a href="#3-hdfs-site-xml" class="headerlink" title="3.hdfs-site.xml"></a>3.hdfs-site.xml</h4><pre><code>&lt;configuration&gt;
&lt;property&gt;
  &lt;property&gt; 
     &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;
  &lt;value&gt;master:50090&lt;/value&gt;
&lt;/property&gt;
  &lt;property&gt;
     &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;1&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
     &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
     &lt;value&gt;file:/usr/hadoop/hadoop-2.6.0/tmp/dfs/name&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
     &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;
     &lt;value&gt;file:/usr/hadoop/hadoop-2.6.0/tmp/dfs/data&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
     &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;
     &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;dfs.nameservices&lt;/name&gt;
    &lt;value&gt;hadoop-cluster1&lt;/value&gt;
 &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>注意：/home/hadoop/hadoop-2.6.0/dfs/name 和 /home/hadoop/hadoop-2.6.0/dfs/data，这两个文件夹要手动创建</p>
<h4 id="4-mapred-site-xml"><a href="#4-mapred-site-xml" class="headerlink" title="4.mapred-site.xml"></a>4.mapred-site.xml</h4><pre><code>&lt;configuration&gt;
&lt;property&gt;
            &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
            &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
            &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;
            &lt;value&gt;master:10020&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
            &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;
            &lt;value&gt;master:19888&lt;/value&gt;
    &lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;mapreduce.jobtracker.http.address&lt;/name&gt;
    &lt;value&gt;master:50030&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
            &lt;name&gt;mapred.job.tracker&lt;/name&gt;
            &lt;value&gt;http://master:9001&lt;/value&gt;
&lt;/property&gt;
&lt;/configuration&gt;
</code></pre><h4 id="5-yarn-site-xml"><a href="#5-yarn-site-xml" class="headerlink" title="5.yarn-site.xml"></a>5.yarn-site.xml</h4><pre><code>&lt;configuration&gt;

&lt;!-- Site specific YARN configuration properties --&gt;

&lt;property&gt;
     &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
     &lt;value&gt;master&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;
    &lt;value&gt;master:8032&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;
    &lt;value&gt;master:8030&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;
    &lt;value&gt;master:8031&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;
    &lt;value&gt;master:8033&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;
    &lt;value&gt;master:8088&lt;/value&gt;
&lt;/property&gt;

&lt;/configuration&gt;
</code></pre><h4 id="6-slaves"><a href="#6-slaves" class="headerlink" title="6.slaves"></a>6.slaves</h4><pre><code>master
slave1
slave2
</code></pre><h3 id="4-将master上配置好的hadoop目录拷贝到slave1，slave2"><a href="#4-将master上配置好的hadoop目录拷贝到slave1，slave2" class="headerlink" title="4.将master上配置好的hadoop目录拷贝到slave1，slave2"></a>4.将master上配置好的hadoop目录拷贝到slave1，slave2</h3><pre><code>scp -r /usr/hadoop/hadoop-2.6.0 hadoop@slave1:/usr/hadoop/
scp -r /usr/hadoop/hadoop-2.6.0 hadoop@slave2:/usr/hadoop/
</code></pre><h3 id="5-验证"><a href="#5-验证" class="headerlink" title="5.验证"></a>5.验证</h3><p>master机器上，进入到hadoop根目录</p>
<p>格式化    </p>
<pre><code>bin/hdfs namenode -format
</code></pre><p>启动hadoop</p>
<pre><code>sbin/start-all.sh
</code></pre><p>查看是否正常，通过jps命令如果有一下内容说明ok</p>
<p>master下有：</p>
<blockquote>
<p>ResourceManager</p>
<p>NameNode</p>
<p>SecondaryNameNode</p>
</blockquote>
<p>slave下有：</p>
<blockquote>
<p>DataNode</p>
<p>NodeManager</p>
</blockquote>
<p>浏览器访问：http:master:50070/ 和 <a href="http://master:8088" target="_blank" rel="external">http://master:8088</a></p>
<p>查看状态：bin/hdfs dfsadmin -report</p>
<h2 id="安装scala"><a href="#安装scala" class="headerlink" title="安装scala"></a>安装scala</h2><p><a href="http://www.scala-lang.org/download/2.11.6.html" target="_blank" rel="external">scala下载</a></p>
<p>切换至root用户</p>
<pre><code>sudo su
</code></pre><p>创建/usr/scala文件夹</p>
<pre><code>mkdir /usr/scala
</code></pre><p>将压缩包解压至/usr/scala目录</p>
<pre><code>tar zxvf /opt/scala-2.11.6.tgz -C /usr/scala
</code></pre><p>配置环境变量</p>
<pre><code>vi /etc/profile
#追加如下内容
export SCALA_HOME=/usr/scala/scala-2.11.6
export PATH=$PATH:$SCALA_HOME/bin
</code></pre><p>使环境变量生效</p>
<pre><code>source /etc/profile
</code></pre><p>测试环境变量设置</p>
<pre><code>scala -version
</code></pre><h2 id="Spark安装与配置"><a href="#Spark安装与配置" class="headerlink" title="Spark安装与配置"></a>Spark安装与配置</h2><h3 id="1-spark下载与解压"><a href="#1-spark下载与解压" class="headerlink" title="1.spark下载与解压"></a>1.spark下载与解压</h3><p><a href="http://www.apache.org/dyn/closer.lua/spark/spark1.6.3/spark-1.6.3-bin-hadoop2.6.tgz" target="_blank" rel="external">Spark下载</a></p>
<p>将压缩包解压至/usr/spark目录</p>
<pre><code>tar zxvf /opt/spark1.6.3-bin-hadoop2.6.tgz -C /usr/spark
</code></pre><p>将spark文件夹授权给hadoop用户</p>
<pre><code>chown -R hadoop:hadoop /usr/spark/
</code></pre><h3 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="2.设置环境变量"></a>2.设置环境变量</h3><pre><code>vi /etc/profile
#追加如下内容
export SPARK_HOME=/usr/spark/spark-1.6.3-bin-hadoop2.6
export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin
</code></pre><p>使环境变量生效</p>
<pre><code>source /etc/profile
</code></pre><p>测试环境变量设置</p>
<pre><code>spark-shell --version
</code></pre><p>运行SparkPi</p>
<pre><code>run-example org.apache.spark.examples.SparkPi 10
</code></pre><h3 id="3-配置Spark"><a href="#3-配置Spark" class="headerlink" title="3.配置Spark"></a>3.配置Spark</h3><p>切换至hadoop用户</p>
<pre><code>su hadoop
</code></pre><p>修改spark-env.sh</p>
<pre><code>cd /usr/spark/spark-1.6.3-bin-hadoop2.6/conf
cp spark-env.sh.template spark-env.sh
vi spark-env.sh
#追加如下内容
export SCALA_HOME=/usr/scala/scala-2.12.0
export JAVA_HOME=/usr/jdk
export SPARK_MASTER_IP=10.108.101.27
export SPARK_WORKEY_MOMORY=1024m
</code></pre><p>启动spark</p>
<pre><code>/usr/spark/spark-1.6.3-bin-hadoop2.6/sbin/start-all.sh
#停止命令
/usr/spark/spark-1.6.3-bin-hadoop2.6/sbin/stop-all.sh

#另一种方式
start-master.sh
start-slave.sh spark://10.108.101.210:7077
</code></pre><p>提交任务到spark集群</p>
<pre><code>spark-submit --master spark://master:7077 --class org.apache.spark.examples.SparkPi --name Spark-Pi /usr/spark/spark-1.6.3-bin-hadoop2.6/lib/spark-examples-1.6.3-hadoop2.6.0.jar
</code></pre><p>使用web查看Spark运行状态</p>
<h3 id="4-在Yarn中执行Spark任务"><a href="#4-在Yarn中执行Spark任务" class="headerlink" title="4.在Yarn中执行Spark任务"></a>4.在Yarn中执行Spark任务</h3><p>编辑spark-env.sh</p>
<pre><code>vi /usr/spark/spark-1.6.3-bin-hadoop2.6/conf/spark-env.sh
#追加如下内容
export HADOOP_CONF_DIR=/usr/hadoop/hadoop-2.6.0/etc/hadoop
</code></pre><p>运行SparkLR程序，提交Spark任务到yarn中</p>
<pre><code>spark-submit --master yarn-cluster --class org.apache.spark.examples.SparkLR --name SparkLR /usr/spark/spark-1.6.3-bin-hadoop2.6/lib/spark-examples-1.6.3-hadoop2.6.0.jar
</code></pre><p>使用web查看任务运行状态</p>
<pre><code>http://master:8088/
</code></pre><p><img src="http://7xruqa.com1.z0.glb.clouddn.com/spark%20on%20yarn%E8%BF%90%E8%A1%8C%E5%9B%BE.jpg" alt=""></p>
<p>在Yarn中结合HDFS运行Spark任务</p>
<p>运行JavaWordCount程序</p>
<pre><code>spark-submit --master yarn-cluster --class org.apache.spark.examples.JavaWordCount --name JavaWordCount /usr/spark/spark-1.6.3-bin/hadoop2.6/lib/spark-examples-1.6.3-hadoop2.6.0.jar hdfs://master:9000/user/hadoop/input.txt
</code></pre><font color="red">注意:hdfs://master:9000/user/hadoop/input是输入文件的地址，把需要进行wordcount的数据上传到hdfs文件系统当中</font>

<blockquote>
<p>bin/hadoop dfs -ls    //列出HDFS下的文件</p>
<p>bin/hadoop dfs -ls in //列出HDFS文件下名为in的文档中的文件</p>
<p>bin/hadoop dfs test1 test  //将hadoop目录下的test1文件上传到HDFS上并重命名为test</p>
<p>bin/hadoop dfs -get in getin   //将HDFS中的in文件复制到本地系统并命名为getin</p>
<p>bin/hadoop dfs -cat in/*   //查看HDFS下in文件中的内容</p>
</blockquote>
<p>查看运行结果，因为该示例程序输出结果到控制台，所以我们去查看控制台日志</p>
<blockquote>
<p>1.点击History（上图中红色框尾部）</p>
<p>2.点击Logs（位置在右下部，与history类似）</p>
<p>3.点击stdout:Total file length is XXXXX bytes.</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javaweb开发之Servlet总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/09/javaweb开发之Servlet总结/" class="article-date">
  	<time datetime="2016-10-09T07:53:15.000Z" itemprop="datePublished">2016-10-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/09/javaweb开发之Servlet总结/">javaweb开发之Servlet总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h2><p>Java Servlet 是运行在Web服务器或应用服务器上的程序，它时作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。</p>
<p>使用Sevlet，可以收集来自网页变淡的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<p>Java Servlet通常情况下与使用CGI(Common Gateway Interface，公共关系接口)实现的程序可以达到异曲同工的效果，但是相比于CGI，Servlet有以下几点优势：</p>
<blockquote>
<ol>
<li><p>性能明显更好</p>
</li>
<li><p>Servlet在Web服务器的地址空间内执行，这样它就没必要再创建一个单独的进程来处理每个客户端请求</p>
</li>
<li><p>Servlet是独立于平台的，因为他们使用Java编写的</p>
</li>
<li><p>服务器上的Java安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此Servlet是可信的</p>
</li>
<li><p>java类库的全部功能对Servlet来说都是可用的，它可以通过sockets和RMI机制与applets，数据库或其他软件进行交互。</p>
</li>
</ol>
</blockquote>
<h2 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h2><p>Servlet执行以下主要任务：</p>
<blockquote>
<ol>
<li>读取客户端（浏览器）发送的显示的数据。这包括网页上的HTML表单，或者夜可以是来自applet或自定义的HTTP客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的HTTP请求数据，这包括cookies，媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行RMI或CORBY调用，调用Web服务，或者直接计算得出对应的响应</li>
<li>发送显示的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML或XML），二进制文件（GIF图像），Excel等。</li>
<li>发送隐式的HTTP响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（如HTML），设置cookies和缓存参数，以及其他类似的任务。</li>
</ol>
</blockquote>
<h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><p>Servlet生命周期可被定义为从创建直到毁灭的整个过程。以下是Servlet遵循的过程：</p>
<blockquote>
<ul>
<li>Servlet 通过调用init()方法进行初始化</li>
<li>Servlet 调用service() 方法来处理客户端的请求</li>
<li>Servlet 通过调用destory()方法终止（结束）</li>
<li>最后，Servlet 是由JVM的垃圾回收器进行垃圾回收的</li>
</ul>
</blockquote>
<h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h3><p>init()方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时都不再调用。因此它是用于一次性初始化，就像Applet的init方法一样。</p>
<p>Servlet创建于用户第一次调用对应于该Servlet的URL时，但是也可以在服务器第一次启动时被加载。当用户调用一个Servlet时，就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候交给doGet和doPost方法。init()方法简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。</p>
<p>init方法的定义如下</p>
<pre><code>public void init() throws ServletException{
       //初始化代码...
}
</code></pre><h3 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h3><p>service()方法是执行实际任务的主要方法。Servlet容器（即Web服务器）调用service()方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service()方法检查HTTP请求类型(GET,POST,PUT,DELETE等)，并在适当的时候调用doGET，doPost，doPut，doDelete等方法。</p>
<p>下面是该方法的特征：</p>
<pre><code>public void service (ServletRequest request,ServletResponse response) throws ServletException, IOException{

}
</code></pre><p>service()方法由容器调用，service方法在适当的时候调用doGet，doPost，doPut，doDelete等方法。所以不用对service方法做任何动作，只需要根据来自客户端的请求类型来重载doGet()或doPost()即可。</p>
<h3 id="destory-方法"><a href="#destory-方法" class="headerlink" title="destory()方法"></a>destory()方法</h3><p>destory()方法只会被调用一次，在Servlet生命周期结束时被调用。destory()方法可以让Servlet关闭数据库连接，停止后台线程，把cookie列表或点击计数器写入到磁盘，并执行其他类似的清理活动。<br>在调用destory()方法之后，servlet对象被标记为垃圾回收。destory方法定义如下所示：</p>
<pre><code>public void destroy(){
    //终止化代码...
}
</code></pre><p>生命周期架构图:</p>
<p><img src="http://7xruqa.com1.z0.glb.clouddn.com/servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java异常处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/20/java异常处理机制/" class="article-date">
  	<time datetime="2016-09-20T07:46:15.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/20/java异常处理机制/">java异常处理机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>原文<a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/6155636</a></em></p>
<blockquote>
<p>在面向过程式的变成语言中，我们可以通过返回值来确定方法是否正常执行。比如在一个C语言编写的程序中，如果方法正确的执行返回1，错误则返回0。通过方法的返回值我们并不能获得错误的详细信息，可能因为方法由不同的程序员编写，当同一类错误在不同的方法出现时，返回的结果和错误信息不一致。</p>
</blockquote>
<p>什么是异常？运行时发生的可被捕获和处理的错误。</p>
<h1 id="1-java异常"><a href="#1-java异常" class="headerlink" title="1.java异常"></a>1.java异常</h1><p>异常指不期而遇的各种状况，如文件找不到，网络连接失败，非法参数等。异常是一个事件，它发生运行期间，干扰了正常的指令流程。java通过API中Throwable类的众多子描述各种不同的异常。因而，java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。</p>
<p>java异常类层次结构图：</p>
<p><img src="http://7xruqa.com1.z0.glb.clouddn.com/java%E5%BC%82%E5%B8%B8%E7%B1%BB.PNG" alt=""></p>
<p>在java中，所有的异常都有一个共同的祖先Throwable（可抛出）。Throwalbe指定代码中可用异常传播机制通过java应用程序传播的任何问题的共性。</p>
<font color="blue"><b>Throwable：</b></font>有两个重要的子类：Exception(异常)和Error（错误），二者都是java异常处理的重要子类，各自都包含大量子类<br><br><font color="blue"><b>Error(错误)：</b></font>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写执行的操作无关，而表示代码运行时JVM（java虚拟机）出现问题。eg，java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资料，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<br><br><font color="blue"><b>Exception(异常)：</b></font>是程序本身可以处理的异常<br><br>Exception类有一个重要的子类RuntimeException。RuntimeException类及其子类表示“JVM常用操作”引发的错误。例如，若视图使用空值对象引用，除数为0或数组越界，则分别引发运行时异常（NullPointerException，ArithmeticException）和ArrayIndexOutOfBoundException。<br><br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于<font color="blue"><b>可查异常</b></font>。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。<br><br><br><font color="blue"><b>为什么Java的checked exception是一个糟糕的特性？</b></font>

<blockquote>
<p>当少量代码时，checked异常无疑是十分优雅的构思，并有助于避免了许多潜在的错误，但是经验表明，对大量代码来说结果正好相反。<br>使用checked异常会带来许多问题</p>
<p>1.checked异常导致了太多的try…catch代码</p>
<p>2.checked异常导致了许多难以理解的代码产生</p>
<p>当开发人员必须去捕获一个自己无法正确处理的checked异常，通常的是重新封装成一个新的异常后再抛出。这样做并没有为程序带来任何好处。反而使代码晚难以理解。就像我们使用JDBC代码那样，需要处理非常多的try…catch.，真正有用的代码被包含在try…catch之内。使得理解这个方法变理困难起来checked异常导致异常被不断的封装成另一个类异常后再抛出。</p>
<p>3.checked异常导致破坏接口方法</p>
<p>一个接口上的一个方法已被多个类使用，当为这个方法额外添加一个checked异常时，那么所有调用此方法的代码都需要修改</p>
</blockquote>
<font color="blue"><b>运行时异常：</b></font>

<blockquote>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
</blockquote>
<font color="blue"><b>非运行时异常 （编译异常）：</b></font>

<blockquote>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
</blockquote>
<h1 id="2-处理异常机制"><a href="#2-处理异常机制" class="headerlink" title="2.处理异常机制"></a>2.处理异常机制</h1><p>由于运行时异常的不可查性，为了更合理，更容易地实现应用程序，java规定，运行时异常将有java运行时系统自动抛出，允许应用程序忽略运行时异常。</p>
<p>对于所有可查异常，java 规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p>
<p>从方法中抛出的任何异常都必须使用throws字句，捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><font color="green"><b>1.try-catch语句</b></font>

<p>在java中，异常通过try-catch语句捕获。其一般语法形式为：</p>
<pre><code>try{
    //可能会发生异常的程序代码
}catch(Type1 id1){
     //捕获并处置try抛出的异常类型Type1
}catch(Type2 id2){
     //捕获并处置try抛出的异常类型Type2
}
</code></pre><p>java通过异常类描述异常类型，异常类的层次结构如图所示。对于多个catch子句的异常程序而言，应该尽量捕获底层异常类的catch子句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获地城异常类的catche子句将可能会被屏蔽。</p>
<blockquote>
<p> RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</p>
</blockquote>
<font color="green"><b>2.try-catch-finally语句</b></font>

<p>try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。try-catch-finally语句的一般语法形式为：</p>
<pre><code>try{
    //可能会发生异常的程序代码
}catch(Type1 id1){
    //捕获并处理try抛出异常类型Type1
}catch(Type2 id){
    //捕获并处理try抛出的异常类型Type2
}
</code></pre><font color="blue"><b>try，catch，finally语句块的执行顺序</b></font>

<blockquote>
<p>1）当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</p>
<p>2）当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块是，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行</p>
<p>3）当try捕获到异常，catch语句块里面有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将调到catch块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句。</p>
</blockquote>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>任何java代码都可以抛出异常，如：自己编写的代码，来自java开发环境包中代码，或者java运行时系统，无论是谁，都可以通过java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</p>
<font color="green"><b>1.throws抛出异常</b></font>

<p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：</p>
<pre><code>methodname throws Exception1，Exception2，...，ExceptionN
</code></pre><p>方法名后的throws Exception1，Exception2，…，ExceptionN为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常做处理，而抛向调用该方法的方法，由他去处理。例如：</p>
<pre><code>import java.lang.Exception;
public class TestException{
static void pop() throws NegativeArraySizeException{
    int[] arr=new int[-3];//创建数组
}

public static void main(String[] args){
     try{
          pop();
     }catch(NegativeArraySizeException e){
         System.out.println(&quot;pop()方法抛出的异常&quot;); //输出异常信息
     }
}
}
</code></pre><p>使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。</p>
<font color="blue"><b>throws抛出异常的规则：</b></font>

<blockquote>
<p>1）如果是不可查异常（unchecked exception），即Error，RuntimeException或他们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</p>
<p>2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能会出现可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误。</p>
<p>3）仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者物理处理该异常的时候，应该继续抛出。</p>
<p>4）调用方法必须遵循任何客场异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</p>
</blockquote>
<p>例如：</p>
<pre><code>void method1() throws IOException{}  //合法    

//编译错误，必须捕获或声明抛出IOException    
void method2(){    
  method1();    
}    

//合法，声明抛出IOException    
void method3()throws IOException {    
  method1();    
}    

//合法，声明抛出Exception，IOException是Exception的子类    
void method4()throws Exception {    
  method1();    
}    

//合法，捕获IOException    
void method5(){    
 try{    
    method1();    
 }catch(IOException e){…}    
}    

//编译错误，必须捕获或声明抛出Exception    
void method6(){    
  try{    
    method1();    
  }catch(IOException e){throw new Exception();}    
}    

//合法，声明抛出Exception    
void method7()throws Exception{    
 try{    
  method1();    
 }catch(IOException e){throw new Exception();}    
}   
</code></pre><font color="green"><b>2.使用throw抛出异常</b></font>

<p>throw总是出现在函数体重，用来抛出一个Throwalbe类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含他的所有try块中（可能在上层调用函数中）从里向外寻找憨厚与其匹配的catch子句的try块。</p>
<p>我们知道，异常时候异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出，该语句的语法格式为：</p>
<pre><code>throw new exceptionname;
</code></pre><p>例如抛出一个IOException类的异常对象：</p>
<pre><code>throw new IOException;
</code></pre><p>要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：</p>
<pre><code>throw new String(&quot;exception&quot;);
</code></pre><p>这是因为String 不是Throwable 类的子类。</p>
<p>如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</p>
<p>如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</p>
<pre><code>package Test;  
import java.lang.Exception;  
public class TestException {  
    static int quotient(int x, int y) throws MyException { // 定义方法抛出异常  
        if (y &lt; 0) { // 判断参数是否小于0  
            throw new MyException(&quot;除数不能是负数&quot;); // 异常信息  
        }  
        return x/y; // 返回值  
    }  
    public static void main(String args[]) { // 主方法  
        int  a =3;  
        int  b =0;   
        try { // try语句包含可能发生异常的语句  
            int result = quotient(a, b); // 调用方法quotient()  
        } catch (MyException e) { // 处理自定义异常  
            System.out.println(e.getMessage()); // 输出异常信息  
        } catch (ArithmeticException e) { // 处理ArithmeticException异常  
            System.out.println(&quot;除数不能为0&quot;); // 输出提示信息  
        } catch (Exception e) { // 处理其他异常  
            System.out.println(&quot;程序发生了其他的异常&quot;); // 输出提示信息  
        }  
    }  

}  
class MyException extends Exception { // 创建自定义异常类  
    String message; // 定义String类型变量  
    public MyException(String ErrorMessagr) { // 父类方法  
        message = ErrorMessagr;  
    }  

    public String getMessage() { // 覆盖getMessage()方法  
        return message;  
    }  
}  
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java学习路线图" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/18/java学习路线图/" class="article-date">
  	<time datetime="2016-09-18T02:40:28.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/java学习路线图/">java学习路线图</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>转载于北邮人<a href="https://bbs.byr.cn/#!article/Java/33514?p=1" target="_blank" rel="external">https://bbs.byr.cn/#!article/Java/33514?p=1</a></em></p>
<p>Java是一个通用的编程语言，其实可以干很多事，怎么学Java就看怎么用了。</p>
<p>但有一些一般的步骤：</p>
<ol>
<li><p>熟悉一种文本编辑器，比如Vim, Emacs, Notepad++, TextMate等。知道哪些是开源的，哪些是闭源的，哪些要收费。养成不用盗版软件的习惯。</p>
</li>
<li><p>安装JDK（建议用你的Linux发行版自带的软件包管理器安装openjdk，过程中可能需要读发行版特定的文档）</p>
</li>
<li><p>写一个Java的Hello world程序，并用命令行工具javac编译，再用java命令运行这个程序。过程中熟悉源代码、字节码、虚拟机这些东西，以及Java的包（package）对.class文件所在的路径的影响。</p>
<p>3.5. 如果这两个命令行工具使用熟练了，可以开始选一个喜欢的集成开发环境，比如Eclipse。当然，养成不用盗版软件的习惯。熟悉一下如何建立“工程”，以及快捷键的使用。</p>
</li>
<li><p>学习Java的面向过程编程，包括基本数据结构、表达式、语句、控制流、函数调用。</p>
</li>
<li><p>学习Java的面向对象编程，包括类、引用类型和值类型的区别、成员、方法、访问控制、继承、多态、接口、接口实现。顺便学习一下面向对象的基本思想，即对象、消息、封装、继承、多态等，这些通用的内容不是Java特有的。</p>
<p>5.5 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，垃圾回收是不会帮你关闭的。</p>
</li>
<li><p>学习Java的异常处理，但更重要的是学习什么时候用特殊返回值而不使用异常，什么时候应该抛出异常而不处理异常，知道什么是pokemon catch及其危害，了解为什么Java的checked exception是一个糟糕的特性。如果愿意，同时学习一下Java1.7的try-with-resource语句和AutoCloseable接口。</p>
</li>
<li><p>熟悉Java常用的数据结构，如基本的数组类型，以及泛型容器（java.util.*），尤其是java.util.List<t>接口和java.util.ArrayList<t>实现；以及java.util.Map<t,u>接口和java.util.HashMap<t,u>实现。（java1.5以前的没有泛型参数的就不用碰了）同时留意一下基本类型int, double等和装箱类型Integer和Double的区别，以及它们是如何自动转换的。</t,u></t,u></t></t></p>
</li>
<li><p>熟悉Java标准库里的各种工具，包括日期时间、字符串格式化、IO等。知道文件要自己在finally子句中close()，或者用Java1.7的try-with-resource，不要妄想垃圾回收器会帮你关掉文件。</p>
</li>
<li><p>学习一下Java的命名习惯，以及JavaBeans的常规，知道为什么getter/setter比直接操作成员变量好。按这种方式给Java的变量、方法命名。同时看看你的IDE能不能自动帮你生成getter和setter。</p>
</li>
<li><p>使用一个第三方的库（比如Apache Commons Lang通用工具库），让你的程序依赖于它的二进制jar包（而不是直接拷贝源代码），用命令行编译、运行（注意classpath等）；也熟悉一下如何用你的集成开发环境添加第三方依赖。感受一下手动管理依赖关系的麻烦。</p>
</li>
<li><p>学习Maven的使用，试着让Maven帮你解决依赖关系，再试着让Maven帮你创建一个Eclipse工程。再试试用Maven打包发布。</p>
</li>
<li><p>学习软件测试，以及JUnit的使用，以及怎么在IDE中使用JUnit。有空看一下coverage工具。</p>
</li>
<li><p>读读四人帮写的《设计模式》（这本书是用C++和Smalltalk语言为例子的，但仍然适合Java）。具体的是这本书， <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="external">http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612</a> 图书馆应该能还借到英文原版，因为我借到过。</p>
</li>
</ol>
<h2 id="接下来就看具体要做哪方面的应用了，看需求。比如（下面的没有顺序）"><a href="#接下来就看具体要做哪方面的应用了，看需求。比如（下面的没有顺序）" class="headerlink" title="接下来就看具体要做哪方面的应用了，看需求。比如（下面的没有顺序）"></a>接下来就看具体要做哪方面的应用了，看需求。比如（下面的没有顺序）</h2><font color="green"><b>【….】如果学Java学得不舒服了，学Python。</b></font>

<blockquote>
<ul>
<li>如果对面向对象编程的概念有点不习惯，学Smalltalk。（Ruby也行，但不如Smalltalk经典。Ruby的文档是一大硬伤。）</li>
<li>如果嫌Java太啰嗦，学Python</li>
<li>如果嫌Java太啰嗦，又想用JVM，自己又有精力，学Scala</li>
<li>如果对对象之间的关系有点晕，学一学UML，以及它的一些图，可以对程序和运行进行直观的建模。你的IDE也许有插件可以生成UML图。但是不要太沉迷于这些方法论。</li>
</ul>
</blockquote>
<font color="green"><b>【调试和辅助工具】学习一下你的集成开发环境提供的调试工具，加一些断点试试 </b></font>

<blockquote>
<ul>
<li>试试用jconsole或者VisualVM监控另一个jvm的状态。</li>
<li>用profiling工具寻找程序中慢的地方。Eclipse有profiling工具。VisualVM也有这样的功能。（如果不介意使用闭源软件的话，也试试JProfiler和YourKit）</li>
<li>有的JVM允许在运行时更新代码。Eclipse可以和某些JVM集成。这样你可以频繁修改代码而不用频繁重启JVM。对于某些“重型”工程很有用。（如果不介意使用闭源软件的话，也试试jRebel）</li>
</ul>
</blockquote>
<font color="green"><b>【多线程】学习Java的多线程编程以及lock、condition的用法（包括传统Java的synchronized语句以及新加的java.util.concurrent.*），学习一下如何让线程停下来，以及为什么要频繁确认isInterrupted()而不要用Thread.stop()。了解一下多核处理器、缓存、内存的关系，以及为什么多线程编程这么难。</b></font>

<blockquote>
<ul>
<li>如果还舒服，学习一下Runnable的用法，以及自带的Executer等基本多线程工具。</li>
<li>应该已经留意到java.util里面的很多容器不是线程安全的，但是java.util.Collections可以帮你创建一些安全的版本。另外关注一下java.util.concurrent里面有ConcurrentMap等容器可供使用。</li>
<li>如果有空的话，看看memory model（内存一致性模型）和无锁同步（见java memory model和java.util.concurrent.atomic）。</li>
<li>如果还有空，再了解一下除了“共享内存多线程编程”以外有没有别的模型（多进程multi-processing、消息传递message passing等）。</li>
</ul>
</blockquote>
<font color="green"><b>【反射、元编程】学习Java的反射机制，以及Annotation的用法。</b></font>

<blockquote>
<ul>
<li>如果还舒服，试试java.lang.reflect.Proxy的用法。</li>
<li>如果仍然还舒服，玩一玩CGLib（一个第三方的库）。</li>
</ul>
</blockquote>
<font color="green"><b>【网络编程】学习一下IP, TCP协议（计算机专业的应该学过，复习一下），学习Socket编程（注意垃圾回收器不会帮你关掉Socket）。</b></font>

<blockquote>
<ol>
<li>如果不是很关心HTTP，看看java.nio，学习单线程轮询式IO复用（Selector）。<ul>
<li>如果有点不明白nio的意图的话，了解一下c10k问题。 <a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">http://www.kegel.com/c10k.html</a></li>
<li>如果身体没有异样的话，大概了解一下操作系统（包括C语言）提供的select, poll, epoll, kqueue等接口。</li>
<li>如果身体仍然没有异样的话，试着用java.nio写一个文件服务器。</li>
<li>如果还有精力的话，上网扒一扒有没有其他的通信库，如netty等。</li>
</ul>
</li>
<li>如果关心Web还有HTTP，就学习一下HTTP协议，以及用Java进行HTTP的客户端编程。<ul>
<li>如果还舒服，学学HTML，写写HTML的静态网页（不需要Java）</li>
<li>如果还舒服，用Java写一个基于DOM、XPath或者CSS Selector的网页解析器（爬网页）。</li>
<li>如果还舒服，学学Java的Servlet接口（先别学jsp）进行Web服务器端编程。学学标准的Servlet容器怎么用，包括web.xml的用法以及listener、filter等概念。以及某个Servlet容器（如Jetty或者Tomcat）的具体用法。</li>
<li>如果仍然还舒服，试着学一种模板语言（如haml, velocity, freemarker，【还有其他更好的框架吗？我不知道】, String.format，如果真的想学JSP的话JSP倒是也行，但不推荐）。</li>
<li>如果仍然觉得舒服，学学Spring框架中的Web框架，或者Struts，看你的口味。</li>
<li>如果还舒服，看看Spring Bean Container以及里面各种乱七八糟的工具。</li>
<li>如果还舒服，或者有需求，了解一下什么是RESTful Web Service，复习一下HTTP，找找适合的Java工具。</li>
<li>你可能会觉得Jackson是一个解析JSON用的好用的东西。</li>
</ul>
</li>
</ol>
</blockquote>
<font color="green"><b>【数据库】学习一下关系数据库（计算机专业的应该学过，复习一下），包括SQL。选一个数据库管理系统熟悉一下（比如MariaDB，或者（如果你不讨厌Oracle的话）用被Oracle收购了的MySQL。先脱离Java单独学学）。然后看它们的官方文档教你怎么用Java连接这种数据库。这中间会涉及到JDBC接口。同时一定要知道SQL注入安全漏洞，以及掌握如何用PreparedStatement防止注入！！。建议看 <a href="http://bobby-tables.com/" target="_blank" rel="external">http://bobby-tables.com/</a></b></font>

<blockquote>
<ul>
<li>可能中间会涉及“事务”问题，让你不知不觉地开始去了解java transaction api(JTA)。</li>
<li>如果还舒服，学一学对象关系转换（如Hibernate）。</li>
<li>也可以学学非关系数据库，以及如何用Java访问它们。</li>
</ul>
</blockquote>
<font color="green"><b>【日志记录】学习一下slf4j和logback的用法。</b></font>

<blockquote>
<ul>
<li>如果有精力的话，大概了解一下世界上有多少种Java日志框架，以及slf4j是怎么桥接这些框架的。</li>
</ul>
</blockquote>
<font color="green"><b>【构建(build)系统】学习一下Ant的用法。</b></font>

<blockquote>
<ul>
<li>如果还舒服的话，学习一下用Ivy从Maven的仓库里下载软件包，解决依赖关系。</li>
</ul>
</blockquote>
<font color="green"><b>【版本控制】学习一种分布式版本控制器（如Git、Mercurial、Bzr、Darcs等，推荐Git）的基本用法，以及如何用它管理Java工程。希望你已经开始使用Maven了，并且知道为什么把IDE生成的工程文件（如eclipse的.project，.classpath和.metadata）放入版本控制器不好。然后了解一下如何在IDE中使用版本控制（Eclipse自带Git插件）。</b></font>

<blockquote>
<ul>
<li>如果感觉很舒服的话，为你们实验室搭建一个Linux+SSH+Git服务器，装个GitLab（一种Web界面）。</li>
<li>了解“集中式版本控制器”和“分布式版本控制器”的区别，并说服同事们不要再用SVN、CVS或者SourceSafe等老旧的“集中式版本控制器”了。</li>
<li>开设一个GitHub账户。如果你不喜欢Git，就用BitBucket等。</li>
</ul>
</blockquote>
<font color="green"><b>【持续集成】自己（或者为你们实验室）搭建一个持续集成（Continuous Integration）服务器，如Jenkins，定期编译你的程序。建议同时使用Git等分布式版本控制器。</b></font>

<blockquote>
<ul>
<li>如果你做开源软件，试试GitHub和Travis。</li>
</ul>
</blockquote>
<font color="green"><b>【零碎工具】淘一淘java.nio.files里面有什么好用的东东，然后再淘一淘Apache Commons Lang和Commons IO里有什么好用的工具。Commons Logging就不要再用了，用SLF4j和Logback。</b></font>


<font color="green"><b>【XML】学学XML、DOM、XPath。XML这东西到处都可能用到。也可以用它写自己的配置文件。</b></font>

<blockquote>
<ul>
<li>如果觉得不舒服了，就学学JSON和YAML。</li>
<li>如果还是不舒服，就学学文本文件解析。</li>
</ul>
</blockquote>
<font color="green"><b>【语法分析和编译器】学学Antlr或者别的Parser Generator的用法</b></font>

<blockquote>
<ul>
<li>如果觉得舒服，自己写一个计算器。</li>
<li>如果还觉得舒服，自己写一种Domain-Specific Language (DSL)。</li>
</ul>
</blockquote>
<font color="green"><b>【高效容器】学学FastUtil或者Trove，如果你需要进行大量数值运算的话。</b></font>


<font color="green"><b>【分布式计算】学学MapReduce的思想以及它的实现。</b></font>

<blockquote>
<ul>
<li>如果还舒服，学学Scala语言以及号称比MapReduce快得多的Apache Spark。</li>
</ul>
</blockquote>
<font color="green"><b>【进程间通信】看看ActiveMQ、MINA和RMI。</b></font>


<font color="green"><b>【其他语言（JVM）】学习另一门跑在JVM上的语言或者实现（如Groovy、Scala、Clojure、JRuby、Jython、JavaScript……）</b></font>

<blockquote>
<ul>
<li>如果还舒服，学一学Java Scripting API（注意不是JavaScript。给个链接： <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/</a> ），然后试着在自己的Java程序里嵌入脚本。</li>
</ul>
</blockquote>
<font color="green"><b>【其他语言（非JVM）】学习另一门通用脚本语言（如Python、Ruby，其实perl也行，但不推荐），知道什么时候Java不是最好的选择。</b></font>


<font color="green"><b>【Java语言和Java虚拟机】通读一遍（一目十行地读，不用细读）Java Language Specification，以及Java Virtual Machine Specification。</b></font>

<blockquote>
<ul>
<li>了解以下解释器（interpreter）、编译器（compiler）、即时编译器（just-in-time compiler）和优化器（optimiser）的概念。</li>
<li>如果对编译器的话题不感到畏惧，了解一下method JIT和tracing JIT的概念和区别。</li>
</ul>
</blockquote>
<font color="green"><b>【内存管理】学学垃圾回收的几种基本算法，包括mark-sweep、mark-compact、semi-space、generational、mark-region等，各自的性能，以及为什么朴素的reference counting是不完整的。知道为什么finalizer性能很糟糕，而且标准并不要求finalizer在程序退出前一定会执行。</b></font>

<blockquote>
<ul>
<li>如果还舒服，了解一下如何设置Java虚拟机的堆大小限制（如HotSpot虚拟机的-Xmx选项等）。</li>
<li>了解一下Java里的WeakReference以及SoftReference和PhantomReference，以及它们什么时候有用，以及为什么它们实现起来有些困难。</li>
<li>如果有精力，了解一下Hotspot虚拟机的内存管理算法是什么样的。</li>
</ul>
</blockquote>
<font color="green"><b>【动态装载】学学Java的动态装载（class loading）</b></font>

<blockquote>
<ul>
<li>如果还舒服的话，学学OSGI以及它的一种实现（如Felix或者Equinox）</li>
<li>如果仍然很舒服的话，学学写基于Eclipse平台的程序。不是Eclipse集成开发环境，只是利用他们的图形框架，写自己的应用程序。</li>
<li>如果还觉得舒服的话，写Eclipse集成开发环境的插件。</li>
</ul>
</blockquote>
<font color="green"><b>【本地/外语接口】学习一下Java Native Interface（JNI），试着写一个Java和C语言混合编程的程序。</b></font>

<blockquote>
<ul>
<li>如果觉得不舒服了或者觉得欲仙欲死，就学一学Java Native Access（JNA），试一试不用任何胶水代码而从Java直接装载C库，直接调用C函数。</li>
<li>如果连JNA也懒得学，就学一学SWIG，自动生成绑定。</li>
<li>如果觉得舒服，就学一学Java Virtual Machine Tooling Interface（JVMTI），用C程序来监视JVM的状态。</li>
</ul>
</blockquote>
<font color="green"><b>【密码学】学一学密码学，包括编码、密码分析、攻击、对称密钥、公钥系统、数字签名、哈希算法等，看看Java有没有实现。</b></font>

<blockquote>
<ul>
<li>如果觉得有点不舒服（你应该不会觉得舒服吧，除非你是学密码学的，要不然总会觉得自己写的程序有安全漏洞），就写一个“人品计算器”来放松一下，要求每次输入同一个姓名，得到的人品值是固定的，但又要让人无法用别人的人品值猜自己的人品值。</li>
</ul>
</blockquote>
<font color="green"><b>【移动终端】学一学Android开发。</b></font>

<blockquote>
<ul>
<li>如果有精力的话，看看Dalvik虚拟机是怎么回事。</li>
<li>建议买一个iPhone或者iPad，或许你再也不想用Android手机或者平板了。</li>
</ul>
</blockquote>
<font color="green"><b>【历史】如果觉得有些无聊，就去挖一挖历史上比较火的可能和Java相关技术，比如：</b></font>

<blockquote>
<ul>
<li>Applet，想想它比起html5+css3+javascript的缺点在哪里。</li>
<li>AWT、Swing，想想为什么很少有人用Java写图形界面程序。你觉得Swing的程序看上去舒服吗？中国人和残疾人喜欢用Swing程序吗？</li>
<li>JNDI，想想它比起Spring Bean Container的缺点在哪里。</li>
<li>JSP，想想它比起MVC结构的缺点在哪里。</li>
<li>WSDL/SOAP，把它们和XML-RPC、RESTful Web Service比较一下。</li>
<li>XSLT，以及为什么它是图灵完备的。可是它真的比Java本身更好用吗？</li>
<li>Log4j、java.util.logging、Apache Commons Logging，各自有什么问题，以及Log4j的作者本人为什么又开发了SLF4j和Logback？</li>
<li>Java最早是为什么设计的？</li>
<li>Type erasure是怎么回事？为什么ArrayList<int>不行但ArrayList<integer>就可以？挖一挖历史。</integer></int></li>
</ul>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java导出批量文件，打包下载" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/30/java导出批量文件，打包下载/" class="article-date">
  	<time datetime="2016-08-30T06:44:02.000Z" itemprop="datePublished">2016-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/java导出批量文件，打包下载/">java导出批量文件，打包下载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-获取json格式的数据"><a href="#1-获取json格式的数据" class="headerlink" title="1.获取json格式的数据"></a>1.获取json格式的数据</h2><p>Json-lib包是一个beans,collections,maps,java arrays 和XML和Json相互转换的包，主要就是用来解析Json数据</p>
<p>需要导入的依赖包</p>
<blockquote>
<p>commons-beanutils-1.7.0.jar<br>commons-collections-3.2.jar<br>commons-lang-2.4.jar<br>commons-logging-1.1.jar<br>ezmorph-1.0.4.jar<br>json-lib-2.2.3-jdk13.jar</p>
</blockquote>
<p><strong>JSONArray和JSONObject的区别</strong></p>
<pre><code>{
&quot;cat&quot;:&quot;it&quot;,
&quot;language&quot;:[
    {&quot;id&quot;:1,&quot;ide&quot;:&quot;eclipse&quot;,&quot;name&quot;:Java},
    {&quot;id&quot;:2,&quot;ide&quot;:&quot;XCode&quot;,&quot;name&quot;:&quot;Swift&quot;},
    {&quot;id&quot;:3,&quot;ide&quot;:&quot;Visual Stdio&quot;,&quot;name&quot;:&quot;C#&quot;}     
],
&quot;pop&quot;:true
}
</code></pre><p>JsonArray array=object.get(“language”).getAsJsonArray();   </p>
<pre><code>{
&quot;resultcode&quot;: &quot;200&quot;,
&quot;reason&quot;: &quot;successed!&quot;,
&quot;result&quot;: {
    &quot;sk&quot;: {
        &quot;temp&quot;: &quot;24&quot;,
        &quot;wind_direction&quot;: &quot;西南风&quot;,
        &quot;wind_strength&quot;: &quot;2级&quot;,
        &quot;humidity&quot;: &quot;51%&quot;,
        &quot;time&quot;: &quot;10:11&quot;
    }
}
}
</code></pre><p>JsonObject result=json.get(“result”).getAsJsonObject();</p>
<p><strong>转化成json数据</strong></p>
<p><1>List集合转化成json方法</1></p>
<pre><code>List list = new ArrayList();
list.add( &quot;first&quot; );
list.add( &quot;second&quot; );
JSONArray jsonArray2 = JSONArray.fromObject( list );
</code></pre><p><2>Map集合转换成json方法</2></p>
<pre><code>Map map = new HashMap();
map.put(&quot;name&quot;, &quot;json&quot;);
map.put(&quot;bool&quot;, Boolean.TRUE);
map.put(&quot;int&quot;, new Integer(1));
map.put(&quot;arr&quot;, new String[] { &quot;a&quot;, &quot;b&quot; });
map.put(&quot;func&quot;, &quot;function(i){ return this.arr[i]; }&quot;);
JSONObject json = JSONObject.fromObject(map);
</code></pre><p><3>数组转化成json代码</3></p>
<pre><code>boolean[] boolArray = new boolean[] { true, false, true };
JSONArray jsonArray1 = JSONArray.fromObject(boolArray);  
</code></pre><h2 id="2-循环写入文件"><a href="#2-循环写入文件" class="headerlink" title="2.循环写入文件"></a>2.循环写入文件</h2><pre><code> List&lt;String&gt; file =new ArrayList&lt;String&gt;();
 List&lt;File&gt; files=new ArrayList&lt;File&gt;();

 //项目当前的根目录
 String path=request.getSession().getServletContext().getRealPath(File.separator) 

 JSONObject obj=jsonObj.getJSONObject(&quot;ret_info&quot;).getJSONObject(&quot;ret&quot;);

 //根据一个Json数据，循环写入多个文件
 Iterator it=obj.keys();

 while(it.hasNext()){
     String fileName=(String) it.next();
     file.add(fileName);

     File toFile=new File(path+fileName+&quot;.txt&quot;);
     if(!toFile.exists()){
           toFile.createNewFile();
     }
     //文件输出流
     FileoutputStream fos=new FileOutputStream(toFile);
     StringBuffer write=new StringBuffer();

     //要写入文件的内容
     write.append（&quot;*******************&quot;）;
     ...

     try{
        fos.write(write.toString().getBytes(&quot;UTF-8&quot;));
     }
     catch(Exception e){
         e.printStackTrace();
     }
     finally{
         fos.flush();
         fos.close();
 }
}
</code></pre><h2 id="3-文件打包"><a href="#3-文件打包" class="headerlink" title="3.文件打包"></a>3.文件打包</h2><pre><code>for(int i=0;i&lt;file.size();i++){
   String table=file.get(i);
   File tempFile=new File(path+table+&quot;.txt&quot;);
   files.add(tempFile);
}

BufferedInputStream bfs=null;
byte data[]=new byte[1024];
FileOutputStream dest=new FileOutputStream(path+&quot;/&quot;+&quot;导出数据.zip&quot;);
ZipOutputStream out=new ZipOutputStream(new BufferedOutputStream(dest));

for (int i = 0; i &lt; files.size(); i++) {

                 int count;
                 FileInputStream fis = new FileInputStream(files.get(i));
                 bfs = new BufferedInputStream(fis);
                 ZipEntry entry = new ZipEntry(files.get(i).getName());
                 out.putNextEntry(entry);
                 while ((count = bfs.read(data, 0, 1024)) != -1) {
                      out.write(data, 0, count);
                 }
                 bfs.close();
            }
            out.close();
</code></pre><h2 id="4-文件下载"><a href="#4-文件下载" class="headerlink" title="4.文件下载"></a>4.文件下载</h2><pre><code>File filedown=new File(path+&quot;/&quot;+&quot;导出数据.zip&quot;);
            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;
                    + &quot;data.zip&quot;);
            response.setContentLength((int) filedown.length());
            response.setContentType(&quot;application/zip&quot;);// 定义输出类型
            try{
                FileInputStream fis = new FileInputStream(filedown);
                BufferedInputStream buff = new BufferedInputStream(fis);
                byte[] b = new byte[1024];// 相当于我们的缓存
                long k = 0;// 该值用于计算当前实际下载了多少字节
                OutputStream myout = response.getOutputStream();// 从response对象中得到输出流,准备下载
                // 开始循环下载
                while (k &lt; filedown.length()) {
                    int j = buff.read(b, 0, 1024);
                    k += j;
                    myout.write(b, 0, j);
                }
                myout.flush();
            } catch (Exception e) {
                System.out.println(e);
            }
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Mai Taozi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>