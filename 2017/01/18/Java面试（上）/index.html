<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Java面试（上） | 麦桃子的部落格</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java面试
1.九种基本数据类型的大小，以及他们的封装类byte（Byte）：1字节
short（Short）：2字节
int（Integer）：4字节
long（Long）：8字节
float（Float）：4字节
double（Double）：8字节
boolean（Boolean）
char（Character）：2字节
void（Void）
2.Switch能否用string做参数？ch">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试（上）">
<meta property="og:url" content="http://yoursite.com/2017/01/18/Java面试（上）/index.html">
<meta property="og:site_name" content="麦桃子的部落格">
<meta property="og:description" content="Java面试
1.九种基本数据类型的大小，以及他们的封装类byte（Byte）：1字节
short（Short）：2字节
int（Integer）：4字节
long（Long）：8字节
float（Float）：4字节
double（Double）：8字节
boolean（Boolean）
char（Character）：2字节
void（Void）
2.Switch能否用string做参数？ch">
<meta property="og:image" content="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG">
<meta property="og:image" content="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG">
<meta property="og:updated_time" content="2017-01-18T02:55:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试（上）">
<meta name="twitter:description" content="Java面试
1.九种基本数据类型的大小，以及他们的封装类byte（Byte）：1字节
short（Short）：2字节
int（Integer）：4字节
long（Long）：8字节
float（Float）：4字节
double（Double）：8字节
boolean（Boolean）
char（Character）：2字节
void（Void）
2.Switch能否用string做参数？ch">
<meta name="twitter:image" content="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG">
  
    <link rel="alternative" href="/atom.xml" title="麦桃子的部落格" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xruqa.com1.z0.glb.clouddn.com/IMG_myphoto.JPG" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mai Taozi</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">越努力 越幸运</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mai Taozi</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xruqa.com1.z0.glb.clouddn.com/IMG_myphoto.JPG" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Mai Taozi</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Java面试（上）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/18/Java面试（上）/" class="article-date">
  	<time datetime="2017-01-18T02:49:55.000Z" itemprop="datePublished">2017-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java面试（上）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><hr>
<h3 id="1-九种基本数据类型的大小，以及他们的封装类"><a href="#1-九种基本数据类型的大小，以及他们的封装类" class="headerlink" title="1.九种基本数据类型的大小，以及他们的封装类"></a>1.九种基本数据类型的大小，以及他们的封装类</h3><pre><code>byte（Byte）：1字节
short（Short）：2字节
int（Integer）：4字节
long（Long）：8字节
float（Float）：4字节
double（Double）：8字节
boolean（Boolean）
char（Character）：2字节
void（Void）
</code></pre><h3 id="2-Switch能否用string做参数？"><a href="#2-Switch能否用string做参数？" class="headerlink" title="2.Switch能否用string做参数？"></a>2.Switch能否用string做参数？</h3><p>char int byte short可以，java 7之后可以使用string做参数</p>
<h3 id="3-equals和-的区别"><a href="#3-equals和-的区别" class="headerlink" title="3.equals和==的区别"></a>3.equals和==的区别</h3><p>“==”是一个运算符，而equals是object里面的一个方法<br>对于基本类型，在比较大小的时候可以使用“==”，看两个元素是否相等。equals没有用武之地。<br>对于对象之间的比较，“==”是比较两个对象的内存地址是否相等，equals在object也是使用“==”运算符实现的，所以不重写equals方法的类使用是一样的，但是我们一般会在子类中重写他，比较两个对象的内容是否一样。</p>
<h3 id="4-Object有哪些公用方法？"><a href="#4-Object有哪些公用方法？" class="headerlink" title="4.Object有哪些公用方法？"></a>4.Object有哪些公用方法？</h3><p>Object是所有类的父类，任何类都默认继承Object。</p>
<p>1）clone：protect方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常</p>
<p>2）equals：在Object中与“==”是一样的，子类一般都重写该方法</p>
<p>3）hashcode：该方法用于哈希查找，重写equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p>4）getClass：final方法，获得运行时类型</p>
<p>5）wait：是当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(longtimeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生：<br>1.其他线程调用了该对象的notify方法<br>2.其他县城调用了该对象的notfyAll方法<br>3.其他县城调用了interrupt中断该线程<br>4.时间间隔到了<br>此时该县城就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常</p>
<p>6）notify：唤醒在该对象上等待的某个线程</p>
<p>7）notifyAll：唤醒在该对象上等待的所有县城</p>
<p>8）toString：转换成字符串，一般子类都有重写，否则打印句柄</p>
<h3 id="5-Object有哪些公用方法？"><a href="#5-Object有哪些公用方法？" class="headerlink" title="5.Object有哪些公用方法？"></a>5.Object有哪些公用方法？</h3><p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用，软引用，弱引用和虚引用</p>
<p>1）强引用<br>以前我们使用的大部分引用时间上都是强引用，这是使用最普遍的引用，如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它，当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，是程序异常终止，也不会随意回收具有抢引用的对象来解决内存不足问题。</p>
<p>２）软引用（SoftReference）<br>如果一个对象只具有软引用，那就类似于可有可无的生活用品，如果内存空间足够垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用，软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>３）弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可无的生活用品，弱引用和软引用的区别在于：只有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收他的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用锁引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>４）虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收。<br>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会再回收对象的引用之前，把这个虚引用引入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么久可以在所引用的对象内存被回收之前采取必要的行动。</p>
<p>###６.Hashcode的作用。<br>hashCode的存在主要是用于查找的快捷性,如Hashtable,HashMap等,hashCode是用来在散列存储结构中确定对象的存储地址的</p>
<h3 id="7-ArrayList-LinkedList-Vector的区别"><a href="#7-ArrayList-LinkedList-Vector的区别" class="headerlink" title="7.ArrayList,LinkedList,Vector的区别"></a>7.ArrayList,LinkedList,Vector的区别</h3><p>ArrayList和Vector是采用数组方式存储数据,此数组元素大于实际存储的数据以便增加和插入元素,都允许直接序号索引元素,但是插入数据要涉及到数组元素移动等内存操作,所以索引数据块插入数据慢,vector由于使用了synchronized方法(线程安全)所以性能上比ArrayList要差,LinkedList使用双向链表实现存储,按序号索引数据需要进行向前或向后遍历,但是插入数据只需要记录本项的前后项即可,所以插入数据较快.</p>
<p>synchronized</p>
<p>java语音的关键字,当他用来修饰一个方法或者一个代码块的时候,能够保证在同一时刻最多只有一个线程执行该段代码.<br>1)当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时,一个时间内只能有一个线程得到执行,另一个线程必须等待当前线程执行完这个代码块后才能执行该代码块.<br>2)然而,当一个县城访问object的一个sunochronized(this)同步代码块时,另一个线程任然可以访问该object中的非synchronized(this)同步代码块.<br>3)尤其关键的是,当一个线程访问object的一个synchronized(this)同步代码块时,其他线程对object中所有其他synchronized(this)同步代码块的访问被阻塞.<br>4)第三个例子同样适用于其他同步代码块.也就是说,当一个线程访问object的一个synchronized(this)同步代码块时,他就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
<h3 id="8-String、StringBuffer与StringBuilder的区别。"><a href="#8-String、StringBuffer与StringBuilder的区别。" class="headerlink" title="8. String、StringBuffer与StringBuilder的区别。"></a>8. String、StringBuffer与StringBuilder的区别。</h3><p>String：字符串常量<br>StringBuffer：字符串变量（线程安全）<br>StringBuilder：字符串变量（非线程安全）</p>
<p>1）String类型是Java内的对象，是一个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，而且对象多了，Java的垃圾自动回收机制会开始工作，所以效率很低，建议在不断改变String对象的地方不要使用String类型</p>
<p>2）StringBuffer是个可变的对象，就是每次操作都是对对象本身进行操作，而不用生成新的对象，这样效率肯定就会有很大的提高，在大部分情况下StringBuffer的效率要比String类型高</p>
<p>3）StringBuilder与StringBuffer一样是个可变的字符串序列，提供与StringBuffer兼容的API，但是不能保证同步，用在字符串缓冲区被耽搁线程使用的情况，在单机非多线程的情况下使用StringBuilder会有比较好的效率，因为StringBuilder没有处理同步（Synchronized）问题。StringBuffer则会处理同步问题，如果StringBuilder会在多线程下被操作，则要改用StringBuffer，让对象自行管理同步问题。</p>
<p>注意点:<br>在使用StringBuffer时指定其容量，会比不指定其容量要快40%到50%左右，甚至比不指定容量的StringBuilder要快。所以在使用时最后指定其容量，对于性能有很大的提升。</p>
<h3 id="9-Map、Set、List、Queue、Stack的特点与用法。"><a href="#9-Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="9.Map、Set、List、Queue、Stack的特点与用法。"></a>9.Map、Set、List、Queue、Stack的特点与用法。</h3><p>Map：是键值对，键key是唯一不能重复的，一个键对应一个值，值可以重复<br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Map中可以将key和value单独抽取出来，其中KeySet()方法可以将所有的keys抽取成一个set，而Values()方法可以将map中所有的values抽取成一个集合</p>
<p>set：不包含重复元素的集合，set中最多包含一个null元素，只能用Iterator实现单项遍历，set中没有同步方法。</p>
<p>List：有序的可重复集合，可以再任意位置增加删除元素</p>
<p>Queue：遵从先进先出的原则，使用时尽量避免使用add（）和remove（）方法，而是使用offer（）来添加元素，使用poll（）来移除元素，他的有点事可以通过返回值来判断是否成功。LinkedList实现了Queue接口</p>
<p>stack：遵从后进先出的原则，Stack继承自vector。它通过五个操作对类Vector进行扩展，允许将向量视为堆栈，它提供了通常的push和pop操作，以及去堆栈顶点的peek()方法，测试堆栈是否为空的empty方法等。</p>
<h3 id="10-HashMap和HashTable的区别。"><a href="#10-HashMap和HashTable的区别。" class="headerlink" title="10.HashMap和HashTable的区别。"></a>10.HashMap和HashTable的区别。</h3><p>1）HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null（hashMap可以接受null的键（key）和值（value），而hashTable则不行）</p>
<p>2）HashMap是非synchronized，而hashtable是synchronized，这意味着hashtable是线程安全的，多个线程一个共享一个hashtable，而如果没有正确的同步的话，多个线程是不能共享hashMap的。</p>
<p>3）另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。</p>
<p>4）由于hashTable是线程安全的也是synchronized，所以在单线程环境下它比hashMap要慢。如果你不需要同步，只需要单一线程，那么使用hashmap性能要好过HashTable。</p>
<p>5）HashMap不能保证随着时间的推移map中的元素次序是不变的。</p>
<h3 id="11-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"><a href="#11-HashMap和ConcurrentHashMap的区别，HashMap的底层源码。" class="headerlink" title="11.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。"></a>11.HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</h3><p>ConcurrentHashMap融合了hashmap和hashtable二者的优势。hashtable是做了同步的，hashmap未考虑同步，所以hashmap在单线程情况下效率较高，hashtable在多线程情况下，同步操作能保证程序执行的正确性。但是hashtable每次同步执行的时候都要锁住整个结构。</p>
<p>ConcurrentHashMap正式为了解决这个问题而诞生的。ConcurrentHashMap锁的当时是稍微细粒度的。ConcurrentHashMap将hash表分为16个桶（默认值），诸如get，put，remove等常用操作只锁住当前需要用到的桶。</p>
<p>试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而而读线程几乎不受限制），并发性的提升是显而易见的。</p>
<p>更令人惊讶的是Concurrenthashmap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作的锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现的更明显些）。只有在求size等操作时才需要锁定这个表。</p>
<p>而在迭代时，ConcurrenthashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为弱一致迭代器。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据，更重要的，这保证了过个线程并发只想的连续性和扩展性，是性能提升的关键。</p>
<p>HashMap源码分析</p>
<p>1.关键属性</p>
<pre><code>transient Entry[] table；  //存储元素的实体数组
transient int size;  //存放元素的个数
int threshold;   //临界值  当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量
final float loadFactor; //加载因子
transient int modCount;//被修改的次数
</code></pre><p>其中loadFactor加载因子是表示Hash表中元素的填满程度<br>若加载因子越大填满的元素越多，好处是，空间利用率高了，但是冲突的机会加大了，链表长度会越来越长，查找效率降低。反之加载因子越小，填满的元素越少，好处是，冲突的机会减小了了，但空间浪费多了，表中的数据将过于稀疏（很多空间还没有用，就开始扩容了 ）<br>冲突的机会越大，查找的成本越高。</p>
<p>因此，必须在“冲突的机会”与“空间利用率”之间寻找一种平衡与折中，这种平衡与折中本质上是数据结构中有名的“时空”矛盾的平衡与折中。如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点，相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点，不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<p>2.构造方法</p>
<pre><code>public HashMap(int initialCapacity,float loadFactor){
//确保数字合法
if(initialCapacity&lt;0)
    throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;+initialCapacity);
if(initalCapacity&gt;MAXIMUM_CAPACITY)
   intitialCapacity=MAXIMUM_CAPACITY;
if(loadFactor&lt;=0 || Float.isNaN(loadFactor))
   throw new IllegalArgumentException(&quot;ILLegal load factor：&quot;+loadFactor);

//Find a power of 2&gt;=initialCapacity
int capacity=1; //初始容量
while（capacity&lt; initialCapacity）  //确保容量为2 的n次幂，使capacity为大于initialCapacity的最小的2的n次幂 
capacity&lt;&lt;=1;

this.loadFacotor=loadFactor;
threshold=(int)(capactiy*loadFactor);
table=new Entry[capacity];
init();
}

public HashMap(int initialCapacity){
   this(initialCapacity,DEFAULT_LOAD_FACTOR);
}

public HashMap(){
   this.loadFacotr=DEFAULT_LOAD_FACTOR;
   threshold=(int)(DERAULT_INITIAL_CAPACITY*DEFAULT_LOAD_DACTOR);
   table=new Entry[DEFAULT_INITIAL_CAPACITY];
      init();
}
</code></pre><p>我们可以看到在构造HashMap的时候如果我们制定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的，默认的初始容量为16，默认加载因子为0.75。</p>
<p>3.存储数据<br>下面看看HashMap的存储数据的过程是怎样的，首先看看HashMap的put方法：</p>
<pre><code>public V put(K key,V value){
    //若“key为null”，则将该键值对添加到table[0]中。
   if(key==null)
         return putForNullKey(value);
   //若“key不为null”，则计算该key的hash的值，然后在添加到该哈希值对应的链表中。
   int hash=hash(key.hashCode());
   //搜索指定hash值在对应table中的索引
   int i=indexFor(hash,table.length);
   //循环遍历Entry数组，若“该key”对应的键值对已经存在，则使用新的value取代旧的value。然后退出。
   for(Entry&lt;K,V&gt; e=table[i];e!=null;e=e.next){
        Object k;
        if(e.hash==hash&amp;&amp;((k=e.key)==key||key.eauqls(k))){ //如果key相同则覆盖并返回旧值
             V oldValue=e.value;
             e.value=value;
             e.recordAccess(this);
             return oldValue;
         }
    }
    //修改次数+1；
    modCount++;
    //将key-value添加到table[i]处
    addEntry(hash,key,value,i);
    return null;
}
</code></pre><p>上面程序中用到一个重要的内部接口：Map.Entry,每个Map.Entry其实就是一个key-value对。从上面程序中可以看出：当系统决定存储HashMap中的key-value对时，完全没有没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。这也说明了前面的结论：我们完全可以把Map集合中的value当成key的附属，当系统决定了key的存储位置之后，value随之保存在那里即可。</p>
<pre><code>private V putForNullKey(V value){
    for(Entry&lt;K,V&gt; e=table[0];e!=null;e=e.next){
       if(e.key==null){如果有key为null的对象存在，则覆盖掉
          V oldValue=e.value;
          e.value=value;
          e.recordAccesss(this);
          return oldValue;
             }
     }
     modCount++;
     addEntry(0,null,value,0); //如果键为null的话，则hash值为0
     return null；
 }
</code></pre><font color="red"><b>注意：如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0]</b></font>

<p>下面是计算hash码的函数：</p>
<pre><code>//计算hash值得方法，通过键的hashCode来计算
static int hash(int h){
   h^=(h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12);
   return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4);
}
</code></pre><p>得到hash码以后就会通过hash码去计算出应该存储在数组中的索引，计算索引的函数如下：</p>
<pre><code>static int indexFor(int h,int length){   //根据hash值和数组长度算出索引值
    return h &amp; (length-1); //这里不能随便算取，用hash&amp;（length-1）是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出
}
</code></pre><p>这个我们重点说下，我们一般对哈希表的散列很自然的会想到用hash值对length取模（即除法散列法），Hashtable也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;（length-1）的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p>
<p>接下来，我们分析下，为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样保证散列的均匀，同时也提升了效率，其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;（length-1）的最后一位可能为0也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列的到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同的hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀散列。</p>
<p>根据上面put方法的源代码可以看出，当程序试图将一个key-value对放入hashMap中，程序首先根据该key的hashCode（）返回值决定该Entry的存储位置：如果两个Entry的key的hashVode（）返回值相同，那他们的存储位置相同，如果两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有的Entry的value，但key不会覆盖，如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有的Entry形成Entry链，而且新添加的Entry位于Entry链的头部——具体说明继续看addEntry（）方法的说明。</p>
<pre><code>void addEntry(int hash ,K key ,V value,int bucketIndex){
    Entry&lt;K,V&gt; e=table[bucketIndex];  //如果要加入的位置有值，将该位置原先的值设置为新Entry的next，也就是新entry链表的下一个节点。
    table[bucketIndex]=new Entry&lt;&gt;(hash,key,value,e);
    if(size++&gt;=threshold)   //如果大于临界值就扩容
        resize(2*table.length);  //以2的倍数扩容
 }
</code></pre><p>参数bucketIndex及时indexFor函数计算出来的索引值，第二行代码是取得数组中索引为bucketIndex的Entry对象，第三行就是用hash，key，value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表，第四行和第五行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，hashMap扩容是扩为原来的两倍。</p>
<p>4.调整大小<br>resize（）方法如下：<br>重新调整HashMap的大小，newCapacity是调整后的单位</p>
<pre><code>void resize(int newCapacity){
   Entry[] oldTable=table;
   int oldCapacity=oldTalbe.length;
   if(oldCapacity==MAXIMUM_CAPACITY){
       threshold=Integer.MAX_VALUE;
       return ;
   }
   Entry[] new Table=new Entry[newCapacity];
   transfer(new Table);  //用来将原先table的元素全部移到newTable里面
   table=newTable； //再将newTable赋值给table
   threshold=（int）（newCapacity*loadFactor）；//重新计算临界值
}
</code></pre><p>新建一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将hashMap的全部元素添加到新的HashMap中，并重新计算新的数组中的索引位置。</p>
<p>当hashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定，所以为了提高查询的效率，就要对Hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在hashMap数组扩容后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值，也就是说，默认情况下，数组大小为16，那么当HashMap的元素个数超过16</em>0.75=12时候，就吧数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知Hashmap中元素的个数，那么预设元素的个数能够有效的提高hashMap的性能。</p>
<p>5.数据读取</p>
<pre><code>public V get(Object key){
    if(key==null)
       return getForNullKey();
    int hash=hash(key.hashCode());
    for(Entry&lt;K,V&gt; e=table[indexFor(hash,table.length)];e!=null;e.e.next){
           Object k;
           if(e.hash==hash&amp;&amp;((key=e.key)==key||key.equals(k)))
               return e.value;
           }
    return null;
}
</code></pre><p>有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<h3 id="12-TreeMap-HashMap-LindedHashMap的区别"><a href="#12-TreeMap-HashMap-LindedHashMap的区别" class="headerlink" title="12.TreeMap,HashMap,LindedHashMap的区别"></a>12.TreeMap,HashMap,LindedHashMap的区别</h3><p>Map主要用于存储键值对，根据键得到值，因此不允许键重复（重复了覆盖），但允许值重复。</p>
<p>HashMap是一个最常用的Map，他根据键的HashCode值存储数据，根据键可以直接获取他的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。Hashmap最多只允许一条记录的键为null；允许多条记录的值为null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致，如果需要同步，可以用collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrenthashMap.</p>
<p>Hashtable与HashMap类似，它继承自Dictionary类，不同的是，它不允许记录的键或者值为空，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候回比hashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkendHashmap慢，因为LinkedHashMap的遍历速度只和实际熟读有关，和容量无关，而Hashmap遍历的速度和他的容量有关。</p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值得升序排序，也可以制定排序的比较器，当用Iterator遍历TreeMap时，使得记录是排过序的。</p>
<p>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入，删除，定位元素，Hashmap是最好的选择。<br>TreeMap取出来的是排序后的键值对，但如果你要按自然顺序，或自定义排序遍历键，那么TreeMap会更好。<br>LindedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用linkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</p>
<h3 id="13-Collection包结构，与Collections的区别。"><a href="#13-Collection包结构，与Collections的区别。" class="headerlink" title="13.Collection包结构，与Collections的区别。"></a>13.Collection包结构，与Collections的区别。</h3><p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set </p>
<p>Collection是集合类的上级接口，子接口主要有Set 和List、Map。<br>Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="14-try-catch-finally，try里有return，finally还执行么？"><a href="#14-try-catch-finally，try里有return，finally还执行么？" class="headerlink" title="14. try catch finally，try里有return，finally还执行么？"></a>14. try catch finally，try里有return，finally还执行么？</h3><p>1.不管是否有出现异常，finally块中代码都会执行；<br>2.当try和catch中有return时，finally仍然会执行；<br>3.finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把药返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值）所以函数返回值是在finally执行前确定的；<br>4.finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的值</p>
<h3 id="15-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"><a href="#15-Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。" class="headerlink" title="15.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。"></a>15.Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</h3><p><img src="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG" alt="java异常架构图"></p>
<p>1.Throwable<br>Throwable是java语言中所有错误或异常的超类。<br>Throwable包含两个子类：Error和Exception。它们通常用于指示放生了异常情况。<br>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStartTrace（）等接口用于捕获堆栈跟踪数据等信息。</p>
<p>2.Exception<br>Exception及其子类是Throwable的一种形式，它指出了合理的应用程序想要捕获的条件。</p>
<ol>
<li>RuntimeException<br>RuntimeException是那些可能在java虚拟机正常运行期间抛出的异常的超类。<br>编译器不会检查RuntimeException异常。例如，除数为0时，抛出ArithmeticException异常。<br>RuntimeException是ArithmeticException的超类，当代码发生除数为0的情况，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！<br>如果代码会产生RuntimException异常，则需要通过修改代码进行避免。</li>
</ol>
<p>4.Error<br>和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br>和RuntimeException一样， 编译器也不会检查Error。<br>Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>
<p>（1）运行时异常<br>定义：RuntimeException及其子类都被称为运行时异常。<br>特点：java编译器不会检查它，也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。<br>虽然java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。<br>如果产生运行时异常，则需要通过修改代码来进行避免。 </p>
<p>（2）被检查的异常<br>定义：Exception类本身，以及Exception的子类中除了“运行时异常”之外的其他子类都属于被检查异常。<br>特点：java编译器会检查它，此类异常，要门通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone（）接口去克隆一个对象，而该对象对应的类没有实现cloneable接口，就会抛出CloneNotSupportedException异常。<br>被检查异常通常都是可以恢复的。</p>
<p>（3）错误<br>定义：Error类及其子类<br>特点：和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足，约束失败，或是其他程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误。</p>
<p>OOM：<br>（1）OutOfMemoryError异常<br>除了程序计算器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。</p>
<p>java Heap溢出<br>一般的异常信息：java.lang.OutOfMemoryError:java heap sapcess</p>
<p>java堆用于存储对象实力，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<p>出现这种异常，一般手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数（-Xmx与-Xms）的设置是否适当</p>
<p>（2）虚拟机栈和本地方法溢出</p>
<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将会抛出StackOverflowError异常。<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>这里需要注意当栈的大小越大可分配的线程数就越少</p>
<p>（3）运行时常量池溢出</p>
<p>异常信息：java.lang.OutOfMemoryError:PermGen space</p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>
<p>（4）方法区溢出<br>方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。<br>异常信息：java.lang.OutOfMemoryError:PermGen space<br>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量class的应用中，要特别注意这点。</p>
<h3 id="16-java面向对象的三个特征与含义"><a href="#16-java面向对象的三个特征与含义" class="headerlink" title="16.java面向对象的三个特征与含义"></a>16.java面向对象的三个特征与含义</h3><p>对象是类的一个实例，有状态和行为。<br>类是一个末班，它描述一类对象的行为和状态</p>
<p>（1）封装性：将对象的状态信息尽可能的隐藏在对象内部，只保留有限的接口和方法与外界进行交互，从而避免了外界对对象内部属性的破坏。java中使用访问控制符来保护对类，变量，方法和构造方法的访问。</p>
<p>java中支持4种不同的访问权限、<br>默认的，也称为default，在同一包内可见，不使用任何修饰符。<br>私有的，以private修饰符制定，在同一类内可见<br>共有的，以public修饰符指定，对所有类可见。<br>受保护的，以protected修饰符指定，对同一包内的类和所有子类可见</p>
<p>（2）继承</p>
<p>java通过继承创建分等级层次的类，可以理解为一个对象从另一个对象获取属性的过程。类的继承是单一继承，也就是说，一个子类只能拥有一个父类。<br>子类拥有父类所有的成员变量，但对于父类private的成员变量却没有访问权限，这保障了父类的封装性</p>
<p>（3）多态</p>
<p>多态是同一个行为具有多个不同表现形式或形态的能力，多态性是对象多种表现形式的体现。</p>
<h3 id="17-Override和Overload的含义区别。"><a href="#17-Override和Overload的含义区别。" class="headerlink" title="17.Override和Overload的含义区别。"></a>17.Override和Overload的含义区别。</h3><p>方法的重写（Overriding）和重载（Overloading）是java多态性的不同表现。<br>重写（Overriding）是父类与子类之间多态性的一种表现，而重载（Overriding）是一个类中多态性的一种表现，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写（Overriding）。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被屏蔽了。如果在一个类中定义了多个同名的方法，他们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载（Overloading）。不能通过访问权限，返回类型，抛出的异常进行重载。</p>
<p>（1）Override特点<br>1&gt;覆盖的方法标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2&gt;覆盖的方法返回值必须和被覆盖的方法返回一致<br>3&gt;覆盖的方法所抛出的异常必须哟啊和被覆盖方法所抛出的异常一致，或者是其子类；<br>4&gt;方法被定义为final不能被重写<br>5&gt;对于继承来说，如果某一方法在父类中访问权限是private，那么久不能在子类对其进行重写覆盖，如果定义的话，也只是定义了一个新方法，而不会达到重写覆盖的效果。</p>
<p>（2）Overload特点<br>1&gt;在使用重载时只能通过不同的参数样式。例如不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一个方法内的几个参数类型必须不一致）<br>2&gt;不能通过访问权限，返回类型，抛出的异常进行重载<br>3&gt;方法的异常类型和数目不会对重载造成影响<br>4&gt;重载事件通常发生在一个类中，不同方法之间的现象<br>5&gt;存在于同一类中，但是只有虚方法和抽象方法才能被覆写</p>
<p>overload是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的多态机制。 是一种静态的绑定机制（在编译时已经知道具体执行的是哪个代码段）。   </p>
<p>override是覆盖。覆盖是一种动态绑定的多态机制。即在父类和子类中同名元素（如成员函数）有不同 的实现代码。执行的是哪个代码是根据运行时实际情况而定的。 </p>
<h3 id="18-Interface与abstract类的区别。"><a href="#18-Interface与abstract类的区别。" class="headerlink" title="18.Interface与abstract类的区别。"></a>18.Interface与abstract类的区别。</h3><p>(1)抽象类是不能被实例化的类，只能作为其他类继承的基类；<br>   接口则定义了实现某种服务的一般规范（Objective-C中将接口称为“协议”（protocol））,声明了必须的函数和常量，但不指定如何实现<br>(2)子类通过extends关键字来继承抽象类（且只能继承一个）<br>   类通过implenments关键字来实现接口（可以实现多个）<br>(3)在抽象类中定义的所有方法都必须在子类中实现；<br>   当类实现了接口后，接口中的所有方法都必须实现。如果实现类没有实现接口中的所有方法，则必须声明为抽象类。<br>(4)在抽象类中可以实现一些行为（实际上，抽象类可以完全实现，部分实现，根本不实现）<br>   在接口中只能定义方法，不能实现方法</p>
<p>抽象类和接口的选择问题：<br>1.如果要创建一个模型，这个模型将由一些紧密相关的对象采用，就可以使用抽象类，如果要创建由一些不相关对象采用的功能，就使用接口<br>2.如果必须从多个来源继承行为，就是用接口<br>3.如果知道所有类都会共享一个公共的行为实现，就是用抽象类，并在其中实现该行为。在接口中无法实现行为。</p>
<h3 id="19-Static-class-与non-static-class的区别。"><a href="#19-Static-class-与non-static-class的区别。" class="headerlink" title="19.Static class 与non static class的区别。"></a>19.Static class 与non static class的区别。</h3><p>静态类是指在一个类的内部，有定义了一个用static修饰的类，那静态类的功能又体现在哪里呢？可以用C中的结构体内嵌结构体来理解，其次需要了解两个概念：内部类和静态修饰符static。<br>A.首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类，所以没必要专门用一个Java文件存放这个类。<br>B.静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。这样静态内部类就可以理解了，他可以直接被用外部类名+内部类名 获得。</p>
<h3 id="20-java多态的实现原理"><a href="#20-java多态的实现原理" class="headerlink" title="20.java多态的实现原理"></a>20.java多态的实现原理</h3><p>（1）Java多态概述<br>多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用（invokevitual）和接口引用调用（invokeinterface）的实现则有所不同。</p>
<p>类引用调用的大致过程为：Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中的方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法，按照继承关系从下往上搜索。</p>
<p>![JVM运行时结构][2]</p>
<p>  从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量，成员变量，以及方法表。这个类型信息就存储在方法区。<br>  注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像java反射机制那样，通过class对象可以访问到该类的所有信息一样。<br>  【重点】<br>  方法表是实现动态调用的核心，上面讲过方法表存放在方法区中的类型信息，为了优化对象调用方法的速度，方法区的类型会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个想都是对应方法的指针。<br>  【扩展】<br>  方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。<br>  运行时常量池：它是方法区的一部分，Class文件中除了有类的版本，方法，字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。<br>  方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p>
<p>  （2）java的方法调用方式<br>  Java的方法调用有两类，动态方法调用与静态方法调用。<br>  静态方法调用时针对于类的静态方法调用，是静态绑定的，而动态方法调用需要有方法调用所作用的对象，是动态绑定。<br>  类调用（invlkestatic）是在编译时就已经确定好具体调用方法的情况。<br>  实例调用（invlkevitural）则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。<br>  JVM的方法调用指令有四个，分别是invokestatic，invokespecial，invokesvirtual和invlkeinterface。前两个是静态绑定，后两个是动态绑定。</p>
<p>  （3）方法表与方法调用<br>  如有类定义Person，Girl，Boy</p>
<pre><code> class Person{
     public String toString(){
         return &quot;I&apos;m a person&quot;;
     }
     public void eat(){}
     public void speak(){}
}

class Boy extends Person{
     public String toString(){
        return &quot;I&apos;m a boy&quot;;
    }
    public void speak(){}
    public void fight(){}
}

class Girl extends Person{
    public String toString(){
       return &quot;I&apos;m a girl&quot;;
    }
    public void speak(){}
    public void sing(){}
}
</code></pre><p>当这三个类被载入到Java虚拟机之后，方法区中就包含了各自的类的信息，Girl和Boy在方法区中的方法表可表示如下：<br><img src="http://7xruqa.com1.z0.glb.clouddn.com/%E6%96%B9%E6%B3%95%E8%A1%A8.PNG" alt="方法表"></p>
<p>  可以看到，Girl和Boy的方法表包含继承自Object的方法，继承自直接父类的Person的方法及各自新定义的方法。注意方法表条目指向的具体买的方法地址，如Girl继承自Object的方法中，只有toString（）指向自己的实现（Girl的方法代码）其余皆指向Object的方法代码，其继承自Person的方法eat（）和speak（）分别指向Person的方法实现和本身的实现。<br>  如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。因此方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。<br>  Person或Object中的任意一个方法，在他们的方法表和其子类Girl和Boy的方法表中的位置（index）是一样的。这样JVM在调用实例方法只需要制定调用方法表中的第几个方法即可。<br>  如调用如下：</p>
<pre><code>class Party{
    void happHour(){
      Person girl =new Girl();
      girl.speak();
    }
}
</code></pre><p>当编译party类的时候，生成girl.speak()的方法调用假设为：<br>Invlkevitual #12<br>设该调用代码对应着girl.speak();#12是Party类的常量池的索引。JVM执行该调用指令的过程如下所示：</p>
<blockquote>
<p>1)在常量池中找到方法的直接引用<br>2)查看Person的方法表，得到speak方法在该方法表的偏移量（假设为15），这样就得到该方法的直接引用<br>3)根据this指针得到具体的对象（即girl所指向的位于堆中的对象）。<br>4)根据对象得到该对象对应的方法表，根据偏移量15查看有无重写（Override）该方法，如果重写，则可以直接调用（Girl的方法表的speak项指向自身的方法而非父类），如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是Person类）的方法表，同样按照这个偏移量15查看有无该方法。</p>
</blockquote>
<p>（4）接口调用<br>因为Java类是可以同时实现多个接口的，而当用接口调用否个方法的时候，情况就有所不同了。<br>java允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置可能不一样了</p>
<pre><code>interface IDance{
    void dance();
}

class Person{
   public String toString(){
      return &quot;I&apos;m a person&quot;;
   }
   public void eat(){}
   public void speak(){}
}
class Dancer extends Person implements IDance{
   public String toString(){
       return &quot;I&apos;m a dancer.&quot;;
   }
   public void dance(){}
}

class Snake implements IDance{
    public String toString(){
       return &quot;A snake.&quot;;
    }
    public void dance(){
    //snake dance
    }
}
</code></pre><p>可以看到由于接口的接入，继承自于接口IDance的方法dance()在类Dancer和Snake的方法表种的位置已经不一样了，我们无法仅根据偏移量来进行方法的调用。<br>Java对于接口方法的调用时采用搜索方法表的方式，如要在Dancer的方法表种找到dance()方法，必须搜索Dancer的整个方法表。<br>因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是满语接口方法的调用。</p>
<h3 id="21-实现多线程的两种方法，Thread和Runable"><a href="#21-实现多线程的两种方法，Thread和Runable" class="headerlink" title="21.实现多线程的两种方法，Thread和Runable"></a>21.实现多线程的两种方法，Thread和Runable</h3><p>线程的概念：线程（Thread）是指一个任务从头至尾的执行流，线程提供一个运行任务的机制，对于java而言，一个程序中可以并发的执行多个线程，这些线程可以在多处理器上面同时进行，当程序作为一个应用程序运行时，java解释器为main（）方法启动一个线程。</p>
<p>并行与并发</p>
<blockquote>
<p>并发：在单处理器系统中，多个线程共享CPU时间，而操作系统负责调度与分配资源给它们<br>并行：在多处理器系统中，多个处理器可以同时运行多个线程，这些线程在同一时间可以同时运行，而不同于并发，只能多个线程共享CPU时间，同一时间只能运行一个线程。</p>
</blockquote>
<p>线程的创建：<br>1）基础概念：java中每个任务就是一个可运行对象，为了创建任务，必须首先定义任务类，任务类必须实现Runable接口。而线程本质上讲就是便于任务执行的对象。一个线程的执行过程就是一个任务类中run（）方法的执行到结束。<br>2）通过Runnable接口创建线程：</p>
<blockquote>
<p>a.定义一个任务类实现Runnable接口，实现Runnable接口中的run（）方法（run（）方法告知系统线程该如何运行），run（）方法中定义具体的任务代码或处理逻辑。<br>b.定义了任务类后，为任务类创建一个任务对象<br>c.任务必须在线程中执行，创建一个Thread类的对象，将前面创建的实现了Runnable接口的任务类对象作为参数传递给Thread类的构造方法。<br>d.调用Thread类对象的start（）方法，启动一个线程，它会导致任务的run（）方法被执行，当run（）方法执行完毕，则线程就终止。</p>
</blockquote>
<pre><code>package com.muzeet.mutithread;

//每个任务都是Runnable接口的一个实例，任务是可运行对象，线程是便于任务执行的对象，必须创建任务类，重写run方法定义任务
public class ThreadDemo1 implements Runnable{
     private int countDown=10;
     @Override
     //重写run方法，定义任务
     public void run(){
        while(countDown-- &gt;0){
           System.out.println(&quot;$&quot;+Thread.currentThread().getName+&quot;(                &quot;+countDown+&quot;)&quot;);
        }
    }

    public static void main(String[] args){
         Runnable demo1=new ThreadDemo1();

         Thread thread1=new Thread(demo1);
         Thread thread2=new Thread(demo1);
         thread1.start();
         thread2.start();
         System.out.println(&quot;火箭发射倒计时:&quot;); 
    }
}
</code></pre><p>程序运行结果<br>火箭发射倒计时:</p>
<pre><code>    $Thread-0(9)      
$Thread-0(8)
    $Thread-0(7)
$Thread-0(6)
    $Thread-0(5)
$Thread-0(4)
    $Thread-0(3)
$Thread-0(2)
    $Thread-0(1)
$Thread-0(0)
</code></pre><p>同时运行两个任务对象</p>
<pre><code>public static void main(String[] args){
     Runnable demo1=new ThreadDemo1();
     Runnable demo2=new ThreadDemo2();
     Thread thread1=new Thread(demo1);
     Thread thread2=new Thread(demo2);

     thread1.start();
     thread2.start();
     System.out.println(&quot;火箭发射倒计时：&quot;);
 }
</code></pre><p>运行结果</p>
<pre><code>$Thread-0(9)
$Thread-0(8)
$Thread-0(7)
$Thread-0(6)
$Thread-1(9)
$Thread-0(5)
$Thread-1(8)
$Thread-0(4)
$Thread-1(7)
$Thread-0(3)
$Thread-1(6)
$Thread-1(5)
$Thread-0(2)
$Thread-1(4)
$Thread-1(3)
$Thread-1(2)
$Thread-1(1)
$Thread-1(0)
$Thread-0(1)
$Thread-0(0)
</code></pre><p>3）继承Thread类来创建线程：</p>
<blockquote>
<p>a.首先创建一个任务类extends Thread类，因为Thread实现了Runnable接口，所以自定的任务类也实现了Runnable接口，重写run（）方法，其中定义具体的任务代码或处理逻辑。<br>b.创建一个任务类对象，可以用Thread或者Runnable作为自定义的变量类型。<br>c.调用自定义对象的start（）方法，启动一个线程。</p>
</blockquote>
<p>示例代码</p>
<pre><code>package class ExtendFromThread extends Thread{
     private int countDown=10;
     @Override
     //重写run方法，定义任务
     public void run(){
         while(countDown-- &gt;0){
             System.out.println(&quot;$&quot;+this.getName+&quot;(                &quot;+countDown+&quot;)&quot;);
        }
    }
    //调用start方法会启动一个线程，导致任务中的run方法被调用，run方法执行完毕则线程终止

   public static void main(String[] args){
     ExtendFormThread thread1=new ExtendFromThread();
     ExtendFormThread thread2=new ExtendFromThread();
     thread1.start();
     thread2.start();

     System.out.println(&quot;火箭发射倒计时：&quot;)；
   }
}
</code></pre><p>两种方法的比较</p>
<blockquote>
<p>首先分析两种方式的输出结果，同样是创建了两个线程，为什么结果不一样呢？<br>使用实现Runnable接口方式创建线程可以共享一个目标对象（TreadDemo1 tt=new TreadDemo();）,实现多个线程处理同一份资源。当第一个线程执行完任务后，countDown已经为0，所以第二个线程就不会输出。而继承Thread创建线程，new出了两个任务类对象，有各自的成员变量，相互之间不干扰。</p>
</blockquote>
<p>然后再看一段来自JDK的解释：</p>
<blockquote>
<p>Runnable接口应该由那些打算通过某一线程执行其实例的类来实现，类必须定义一个称为run的无参数方法。<br>设计该接口的目的是为了希望在活动时执行代码的对象提供一个公共协议。例如Thread类实现了Runnable。<br>此外，Runnable为非Thread子类的类提供了一种激活方式，通过实例化某个Thread实例并将自身作为运行目标，就可以运行实现Runnable的类。大多数情况下，如果只想重写run（）方法，而不重写其他Thread方法，那么应该使用Runnable接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类（推荐使用创建任务类，并实现Runnable几口，而不是继承Thread类）</p>
</blockquote>
<p>采用继承Thread类方式</p>
<blockquote>
<p>1)优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程,<br>2)缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p>
</blockquote>
<p>采用实现Runnable接口方式：</p>
<blockquote>
<p>1）优点：线程类只是实现了Runnable接口，还可以继承其他的类。在这种情况下，多个线程共享一个目标对象，所以非常适合多个祥泰线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread（）方法。</p>
</blockquote>
<h3 id="22-线程同步的方法：sychronized、lock、reentrantLock等"><a href="#22-线程同步的方法：sychronized、lock、reentrantLock等" class="headerlink" title="22. 线程同步的方法：sychronized、lock、reentrantLock等"></a>22. 线程同步的方法：sychronized、lock、reentrantLock等</h3><p>如果你想一个变量写值，而这个变量接下来可能会被另一个线程读取，或者你从一个变量读值，而它的值可能是前面由另一个线程写入的，此时你就必须使用同步</p>
<p>例子：</p>
<pre><code>package cn.outofmemory.locks;

public class LockDemo implements Runnable {
   private int counter = 0;

   public void run() {
      int loopTimes = 10000;
      while (loopTimes &gt; 0) {
          counter ++;                
          loopTimes --;
      }
   }

  public static void main(String[] args) throws InterruptedException {
     LockDemo demo = new LockDemo();

     Thread[] threads = new Thread[]{
            new Thread(demo), new Thread(demo),new Thread(demo), new Thread(demo),new Thread(demo)
    };


    for (Thread t : threads) {
        t.start();
    }

    for (Thread t : threads) {
        t.join();
    }

    System.out.println(&quot;demo&apos;s counter is &quot; + demo.counter);
}
</code></pre><p>}</p>
<p>这段代码中的LockDemo类实现了Runnable接口，在run方法中对其私有变量counter递加了10000次。在main方法中我们首先初始化了一个LockDemo对象，然后初始化了5个线程，这5个线程公用一个LockDemo的实例。然后我们一次启动这5个线程，然后通过join等待所有线程结束，最后输出demo实例的counter值来。<br>运行程序，得到这样一个输出结果：</p>
<pre><code>demo&apos;s counter is 44041
</code></pre><p>本来5个线程每个线程递加10000次，应该得到的结果是50000，而实际的结果是44041<br>如果你也运行此程序可能会得到不一样的结果，这取决于这5个线程造成了多少次冲突。</p>
<p>冲突的地方在于，他们公用了demo对象，同时对demo对象的成员变量counter做递加，也就是说冲突出现在对counter递加这一步上。<br>我们在这一步操作上加上synchronized关键字，让5个线程执行到对counter++这步代码时单独运行</p>
<p>synchronized在修饰代码块的时候需要一个reference对象作为锁的对象，在修饰方法的时候默认是当前对象作为锁的对象，在修饰类的时候默认是当前类的Class对象作为锁的对象。</p>
<p>修改后的run方法代码：</p>
<pre><code>public void run() {
    int loopTimes = 10000;
    while (loopTimes &gt; 0) {
        synchronized (this) {
            counter ++;                
        }
        loopTimes --;
    }
}
</code></pre><p>synchronized关键字是jvm虚拟机的关键字，在java.util.concurrent.locks命名空间中还有一个Lock接口，和Lock接口的实现类ReentrantLock（可重入锁）。ReentrantLock可以实现和synchronized关键字相同的功能，而且更为灵活，在极端的情况下性能会更好一些。</p>
<pre><code>private final Lock lock=new ReentrantLock();
public void run(){
    int loopTimes=10000;
    while(loopTimes&gt;0){
        try{
          lock.lock();
          counter ++;
        }finally{
           lock.unlock();
        }
        loopTime --;
    }
}
</code></pre><p>在LockDemo中添加了一个final的成员变量lock，它是一个ReentrantLock的实例。在run方法中，在counter++这行代码两边加上try…finally…语句，当线程执行到try块之后，首先通过lock.lock()获得锁，获得锁之后再执行counter++,最后在finally语句块中通过lock的unlock（）方法放锁。</p>
<p>synchronized获得内部锁存在一定的局限</p>
<blockquote>
<p>1.不能中断一个正在试图获得锁的线程<br>2.试图获得锁时不能像trylock那样设定超时时间<br>3.每个锁只有单一的条件，不能像condition那样设置多个</p>
</blockquote>
<p>synchronized关键字和可重入锁ReetrantLock选择的最佳实践：</p>
<blockquote>
<p>1.如果synchronized关键字适合程序，尽量使用它，可以减少代码出错的几率和代码数量<br>2.如果特别需要Lock/Condition结构提供的独有特性，才使用它们<br>3.许多情况下可以使用java.util.concurrent包中的一种机制，它会处理你所有的加锁情况</p>
</blockquote>
<h3 id="23-锁的等级：方法锁、对象锁、类锁"><a href="#23-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="23. 锁的等级：方法锁、对象锁、类锁"></a>23. 锁的等级：方法锁、对象锁、类锁</h3><p>方法锁（synchronized修饰方法时）</p>
<p>通过在方法声明中加入synchronized关键字来声明synchrozied方法。synchronized方法控制对类成员变量的访问：每个类实例对应一把锁，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行。否则所属线程阻塞，方法一旦执行，就独占该锁，只当从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为synchronized的成员函数至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<p>对象锁（synchronized修饰方法块或代码块）<br>当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法，或进入其同步区域时，就必须先获得对象锁，如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放（方法锁也是对象锁）</p>
<p>java的所有对象都包含一个互斥锁，这个锁由JVM自动获取和释放，线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待，synchronized方法正常返回或者异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的一个好处，方法抛出异常的时候，锁仍然可以由JVM来自动释放</p>
<p>对象锁的两种形式</p>
<pre><code>public class Test
{
// 对象锁：形式1(方法锁)
public synchronized void Method1()
{
    System.out.println(&quot;我是对象锁也是方法锁&quot;);
    try
    {
        Thread.sleep(500);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}


// 对象锁：形式2（代码块形式）
public void Method2()
{
    synchronized (this)
    {
        System.out.println(&quot;我是对象锁&quot;);
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }

}
</code></pre><p>类锁（synchronized修饰静态的方法或代码块）</p>
<p>由于一个class不论被实例化多少次，其中静态方法和静态变量在内存中都只有一份，所以一旦一个静态方法被声明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。</p>
<p>对象锁是用来控制实力方法之间的同步，类锁时用来控制静态方法（或静态变量互斥体）之间的同步</p>
<p>类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别。java类可能会有很多个对象，但是只有一个class对象，也就是说类的不同实例之间共享该类的Class对象，Class对象其实也仅仅是一个java对象，只不过有点特殊。由于每个java对象都有一个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。</p>
<pre><code>public class Test
{
// 类锁：形式1
public static synchronized void Method1()
{
    System.out.println(＂我是类锁一号＂);
    try
    {
        Thread.sleep(500);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }

}
// 类锁：形式2
public void Method２()
{
    synchronized (Test.class)
    {
        System.out.println(＂我是类锁二号＂);
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }

    }

}
</code></pre><h3 id="24-写出生产者消费者模式"><a href="#24-写出生产者消费者模式" class="headerlink" title="24.写出生产者消费者模式"></a>24.写出生产者消费者模式</h3><blockquote>
<p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述的是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品，解决生产者/消费者问题的方法可分为两类：（1）采用某种机制保护生产者和消费者之间的同步；（2）在 生产者和消费者之间建立一个管道。第一种方式有较高的效率，并且易于实现，代码的可控性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。</p>
</blockquote>
<p>1.wait()/notify()方法</p>
<p>wait()/notify()方法时基类Object的两个方法，也就意味着所有Java类都会拥有这两个方法，这样我们就可以为任何对象实现同步机制。</p>
<p>wait()方法：当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等待状态，让其他线程执行<br>notify()方法：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。</p>
<pre><code>//实现缓冲区
 public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedList&lt;Object&gt; list=new LinkedList&lt;Object&gt;();   //仓库存储的载体

//生产num个产品
public void produce(int num){
    //同步代码段
    synchronized(list){
        //如果仓库容量不足
        while(list.size()+num&gt;MAX_SIZE){
            System.out.println(&quot;[要生产的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
            try
            {
                //由于条件不满足，生产阻塞
                list.wait();        
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            list.add(new Object());
        }
        System.out.println(&quot;[已经生产产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());
        list.notify();
    }
}
//消费num个产品
public void consume(int num){
    //同步代码段
    synchronized(list){
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                list.wait();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[已经消费产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());  

        list.notifyAll();  
    }
}
//  get/set方法
public LinkedList&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedList&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}


public class Producer extends Thread{
//每次生产的产品数量
private int num;
//所在放置的仓库
private Storage storage;
//构造函数设置仓库
public Producer(Storage storage){
    this.storage=storage;
}
public void run(){
    produce(num);
}

//调用仓库Storage的生产函数
public void produce(int num){

    storage.produce(num);
}
public int getNum(){
    return num;
}
public void setNum(int num){
    this.num=num;
}
public Storage getStorage(){
    return storage;
}
public void setStorage(){
    this.storage=storage;
}
}

public class Consumer extends Thread{
private int num;
private Storage storage;
public Consumer(Storage storage){
    this.storage=storage;
}
public void run(){
    consume(num);
}
public void consume(int num){
    storage.consume(num);
}
public int getNum(){
    return num;
}
public void setNum(int num){
    this.num=num;
}
public Storage getStorage(){
    return storage;
}
public void setStorage(Storage storage){
    this.storage=storage;
}
}
</code></pre><p>2.await()/signal()方法<br>在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步，锁定，线程池等，他们可以实现更细粒度的线程控制。await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和wait()/notify()相同，完全可以取代他们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象绑定，进而控制并发程序访问竞争资源的安全。</p>
<pre><code>//实现缓冲区
public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedList&lt;Object&gt; list=new LinkedList&lt;Object&gt;();   //仓库存储的载体

//锁
private final Lock lock=new ReentrantLock();

//仓库满的条件变量
private final Condition full=lock.newCondition();

//仓库空的条件变量
private final Condition empty=lock.newCondition();

//生产num个产品
public void produce(int num){
    //获得锁
    lock.lock();
        //如果仓库容量不足
        while(list.size()+num&gt;MAX_SIZE){
            System.out.println(&quot;[要生产的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;);
            try
            {
                //由于条件不满足，生产阻塞
                full.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            list.add(new Object());
        }
        System.out.println(&quot;[已经生产产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());

        //唤醒其他所有线程
        full.signalAll();
        empty.signalAll();
        //释放锁
        lock.unlock();

}
//消费num个产品
public void consume(int num){
    //获得锁
    lock.lock();
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                empty.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[已经消费产品数]:&quot; + num + &quot;/t[现仓储量为]:&quot; + list.size());  

        //唤醒其他所有线程
        full.signalAll();
        empty.signalAll();

        //释放锁
        lock.unlock();

}
//  get/set方法
public LinkedList&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedList&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}
</code></pre><p>３. BlockingQueue阻塞队列方法<br>BlockingQueue是JDK5.0的新增内容，它是一个已经在内部实现了同步的队列，实现方式采用是我们第二种await()/signal()方法，它可以在生成对象时指定容量大小，它用于阻塞操作的是put()和take()方法</p>
<p>put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞<br>take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞</p>
<pre><code>public class Storage {
private final int MAX_SIZE=100;  //仓库最大存储量
private LinkedBlockingQueue&lt;Object&gt; list=new LinkedBlockingQueue&lt;Object&gt;(100);


//生产num个产品
public void produce(int num){
    //如果仓库剩余容量为0
    if(list.size()==MAX_SIZE){
        System.out.println(&quot;[库存量]:&quot; + MAX_SIZE + &quot;/t暂时不能执行生产任务!&quot;);  
    }

        //生产条件满足的情况下，生产num个产品
        for(int i=1;i&lt;=num;i++){
            try{
                //放入产品，自动阻塞
                list.put(new Object());
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }

        System.out.println(&quot;/t[现仓储量为]:&quot; + list.size());

    }

}
//消费num个产品
public void consume(int num){
    if(list.size()==0){
        System.out.println(&quot;[库存量]:0/t暂时不能执行生产任务!&quot;);
    }
        //如果仓库存储量不足
        while(list.size()&lt;num){
            System.out.println(&quot;[要消费的产品数量]:&quot; + num + &quot;/t[库存量]:&quot;  
                    + list.size() + &quot;/t暂时不能执行生产任务!&quot;); 
            try{
                //由于条件不足，消费阻塞
                empty.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
        }
        //消费条件满足情况下，消费num个产品
        for(int i=1;i&lt;=num;i++){
            list.remove();
        }
        System.out.println(&quot;[现仓储量为]:&quot; + list.size());  

        //唤醒其他所有线程


}
//  get/set方法
public LinkedBlockingQueue&lt;Object&gt; getList(){
    return list;
}
public void setList(LinkedBlockingQueue&lt;Object&gt; list){
    this.list=list;
}
public int getMAX_SIZE(){
    return MAX_SIZE;
}
}
</code></pre><p>有时使用BlockingQueue可能会出现put()和System.out.println()输出不匹配的情况，这是由于它们之间没有同步造成的。当缓冲区已满，生产者在put()操作时，put()内部调用了await()方法，放弃了线程的执行，然后消费者线程执行，调用take()方法，take()内部调用了signal()方法，通知生产者线程可以执行，致使在消费者的println()还没运行的情况下生产者的println()先被执行，所以有了输出不匹配的情况。</p>
<h3 id="25-ThreadLocal的设计理念与作用"><a href="#25-ThreadLocal的设计理念与作用" class="headerlink" title="25.ThreadLocal的设计理念与作用"></a>25.ThreadLocal的设计理念与作用</h3><p>Jav中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，他们也无法访问到对方的ThreadLocal变量。</p>
<p>1）如何创建ThreadLocal变量</p>
<pre><code>private ThreadLocal myThreadLocal=new ThreadLocal();
</code></pre><p>通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，而且也不需要知道它是被哪个线程实例化，虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set（）方法设置的值，即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。</p>
<p>2）如何访问ThreadLocal变量</p>
<p>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值:</p>
<pre><code>myThreadLocal.set(&quot;A thread local value&quot;);
</code></pre><p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<pre><code>String threadLocalValue=(String) myThreadLocal.get();
</code></pre><p>get()方法返回一个Object对象，set（）方法需要传入一个Object类型的参数</p>
<p>3）为ThreadLocal制定泛型类型<br>我们可以创建一个制定泛型类型的ThreadLocal对象，这样我们就不需要每次对使用get()方法返回的值做强制类型转换了，下面展示了制定泛型类型的ThreadLocal例子：</p>
<pre><code>private ThreadLocal myThreadLocal=new ThreadLocal&amp;lt;String&amp;GT;();
</code></pre><p>现在我们只能往ThreadLocal对象中存入String类型的值了<br>并且我们从ThreadLocal中获取值得时候也不需要强制类型转换了</p>
<p>4）如何初始化ThreadLocal变量的值</p>
<p>由于在TrehadLocal对象中设置的值只能被设置这个值得线程访问到，线程无法在ThreadLocal对象上使用set()方法保存一个初始值，并且这个初始值能被所有线程访问到。<br>但是我们可以通过创建一个ThreadLocal的子类并且重写initialValue（）方法，来为一个ThreadLocal对象制定一个初始值，就像下面代码暂时那样：</p>
<pre><code>private ThreadLocal myThreadLocal =new ThreadLocal&amp;lt;String&amp;gt;(){
@Override
protect String initialValue(){
   return &quot;This is the initial value&quot;;
}
};
</code></pre><p>一个完整的ThreadLocal例子</p>
<pre><code>public class ThreadLocalExample{
    public static class MyRunnalbe implements Runnable{
        private ThreadLocal threadLocal=new ThreadLocal();

        @Override
        public void run(){
           threadLocal.set((int)(Math.random())*100D));
           try{
              Thread.sleep(2000);
           }
           catch (InterruptedException e){
           }
           System.out.println(threadLocal.get());
        }
    }
    public static void main(String[] args){
        MyRunnable shareRunnableInstance=new MyRunnable();
        Thread thread1=new Thread(shareRunnableInstance);
        Thread thread2=new Thread(shareRunnableInstance);
        thread1.start();
        thread2.start();
     }
     }

上面例子创建一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run（）方法，并且都在ThreadLocal实例上保存了不同的值，如果他们访问的不是ThreadLocal对象并且调用的set（）方法被同步了，则第二个线程会覆盖掉第一个线程设置的值，但是由于他们访问的是一个ThreadLocal对象，因此这两个线程都无法看到对方的值，也就是说他们取存的是两个不同的值。
</code></pre><h3 id="26-ThreadPool用法与优势"><a href="#26-ThreadPool用法与优势" class="headerlink" title="26. ThreadPool用法与优势"></a>26. ThreadPool用法与优势</h3><p>Java通过Executors提供四种线程池，分别为：<br>newCachedThreadPool创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程，若无可回收，则新建线程<br>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行<br>newSingleThreadExcutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行。</p>
<p>1）newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，示例的代码：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
for(int i=0;i&lt;10;i++){
     final int index=i;
     try{
         Thread.sleep(index*1000);
     }catch(InterruptedException e){
         e.printStackTrace();
     }
     cachedThreadPool.execute(new Runnable(){
         @Override
         public void run(){
             System.out.println(index);
         }
    });
}

线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程
</code></pre><p>2）newFixedThreadPool<br>创建一个定长线程池，可以控制线程最大并发数，超出的线程会在队列种等待，示例代码如下：</p>
<pre><code>ExecutorService fixedThreadPool=Executors.newFixedThreadPool(3);
for(int i=0;i&lt;10;i++){
    final int index=i;
    fixedThreadPool.execute(new Runnable(){
    @Ovrride
    public void run(){
       try{
          System.out.println(index);
          Thread.sleep(2000);
       }catch(InterruptedException e){
           e.printStackTrace();
       }
    }
});
}
</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。</p>
<p>3）newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行，延迟执行示例代码如下：</p>
<pre><code>ScheduledExecutorService scheduledThreadPool =Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable(){
@Override
public void run{
   System.out.println(&quot;delay 3 seconds&quot;);
}
},3,TimeUnit.SECONDS);
</code></pre><p>表示延迟3秒执行</p>
<p>定期执行示例代码如下：</p>
<pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
   @Override
   public void run(){
      System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
    }
},1,3,TimeUnit.SECONDS);
</code></pre><p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer更安全，功能更强大</p>
<p>4)newSingleThreadExecutor<br>创建一个单线程化得线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行，示例代码如下：</p>
<pre><code>ExecutorService singleThreadExecutor=Executor.newSingleThreadExecutor();
for(int i=0;i&lt;10;i++){
    final int index=i;
    singleThreadExecutor.execute(new Runnable(){
        @Override
        public void run(){
            try{
               System.out.println(index);
               Thread.sleep(2000);
            }catch(InterruptedException e){
               e.printStackTrace();
            }
        }
    });
}
</code></pre><p>结果依次输出，相当于顺序执行各个任务</p>
<p>线程池的优势<br>合理利用线程池能够带来三个好处</p>
<blockquote>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低县城创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用县城吃，必须对其原理了如指掌</li>
</ul>
</blockquote>
<h3 id="27-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"><a href="#27-Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。" class="headerlink" title="27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。"></a>27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</h3><p>java.util.concurrent包含许多线程安全，测试良好，高性能的并发构建块。通过提供一组可靠的，高性能并发构建块，开发人员可以提高并发类的线程安全，可伸缩性，性能，可读性和可靠性。</p>
<p>使用线程的理由：</p>
<blockquote>
<ul>
<li>更易响应的用户界面。事件驱动的GUI工具包（如AWT或Swing）使用单独的事件县城来处理GUI事件，从事件线程中调用通过GUI对象注册的事件监听器，然而，如果事件监听器将执行冗长的任务（如文档拼写检查），那么UI将出现冻结，因为事件线程直到冗长任务完毕之后才能处理其他事件。通过在单独县城中执行冗长操作，当执行冗长后台任务时，UI能继续响应。</li>
<li>使用多处理器。多处理器（MP）系统变得越来越简单，并且分布越来越广泛。因为调度的基本单位通常是线程，所以不管有多少处理器可用，一个县城的应用程序一次只能在一个线程上运行。在设计良好的程序中，通过更好地利用可用的计算机资源，多线程能够提高吞吐量和性能。</li>
<li>简化建模。有效使用线程能够使程序编写变得简单，并易于维护。通过合理使用线程，个别类可以避免一些调度的详细，交叉存取操作，异步IO和资源等待以及其他复杂问题。相反，他们能专注于域的要求，简化开发并改进可靠性。</li>
<li>异步或后台处理。服务器应用程序可以同时服务于许多远程客户机。如果应用程序从socket中读取数据，并且没有数据可以读取，那么对read()的调用将被阻塞，直到有数据可读，在单线程应用程序中，这意味着当某一个线程被阻塞时，不仅处理相应请求要延迟，并且处理所有请求也将延迟，然而，如果每个socket都有自己的IO线程，那么当一个线程被阻塞时，对其他并发请求行为没有影响。</li>
</ul>
</blockquote>
<p>线程安全</p>
<p>如果将这些类用于多线程环境中，虽然确保这些类的线程安全比较困难，但线程安全却是必需的。java.util.concurrent 规范进程的一个目标就是提供一组线程安全的、高性能的并发构建块，从而使开发人员能够减轻一些编写线程安全类的负担。<br>“如果可以从多个线程安全调用类，那么该类就是线程安全的”</p>
<p>要成为线程安全的类，首先它必须在单线程正确运行，如果正确实现了类，那么说明它符合规范，对该类的对象的任何顺序的操作（公共字段的读写，公共方法的调用）都不应该使对象出去无效状态，观察将处于无效状态的对象，或违反类的任何变量，前置条件或后置条件。<br>而且，要成为线程安全的类，在从多个线程访问时，它必须继续正确运行，而不管运行时环境执行那些线程的调度和交叉，且无需对部分调用代码执行任何其他同步。结果是对线程安全对象的操作将用于按固定的整体一致顺序出现所有线程。</p>
<p>如果没有线程之间的某种明确协调，比如锁定，运行时可以随意在需要时在多线程中交叉操作执行。</p>
<p>在 JDK 5.0 之前，确保线程安全的主要机制是 synchronized 原语。访问共享变量（那些可以由多个线程访问的变量）的线程必须使用同步来协调对共享变量的读写访问。java.util.concurrent 包提供了一些备用并发原语，以及一组不需要任何其他同步的线程安全实用程序类。</p>
<p>阻塞队列BlockingQueue<br>java.util.concurrent包里的BlockingQueue接口表示一个线程放入和提取实例的队列。BlockingQueue通常用于一个线程生产对象，而另一个消费这些对象的场景。<br>一个线程将会持续生产新对象并将其插入多队列中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列达到了其临界点，负责生产的线程将会在往里面插入新对象时发生阻塞，它会一个处于阻塞之中，知道负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从阻塞队列中拿出对象，如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p>
<p>可以访问到 BlockingQueue中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o)方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p>
<p>数组阻塞队列 ArrayBlockingQueue<br>ArrayBlockingQueue类实现了BlockingQueue接口。<br>ArrayBlockingQueue是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能存储无限多数量的元素，它有一个同一时间能够存储元素数量的上限。你可以再对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了。<br>ArrayBlockingQueue内部以FIFO（先进先出）的顺序对元素进行存储，队列中的头元素在所有元素之中时放入时间最久的那个，而尾元素则是最短的那个。</p>
<p>以下是在使用ArrayBlockingQueue的时候对其初始化的一个示例：</p>
<pre><code>BlockingQueue queue=new ArrayBlockingQueue(1024);
queue.put(&quot;1&quot;);
Object object=queue.take();
</code></pre><p>以下是使用了Java泛型的一个BlockingQueue示例。注意其中是如何对String元素放入和提取的：</p>
<pre><code>BlockingQueue&lt;String&gt; queue=new ArrayBlockingQueue&lt;String&gt;(1024);
queue.put(&quot;1&quot;);
String string=queue.take();
</code></pre><p>CountDownLatch<br>java.util.concurrent.CountDownLatch是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。CountDownlatch以一个给定的数量初始化。countDown（）每被调用一次，这一数量就减一。通过调用await（）方法之一，线程可以阻塞等待这一数量到达0；<br>以下是一个简单示例，Decrementer三次调用countDown()之后，等待中的Waiter才会从await（）调用中释放出来。</p>
<pre><code>CountDownLatch latch=new CountDownLatch(3);
Waiter waiter =new Waiter(latch);
Decrementer decrementer =new Decrementer(latch);

new Thread(waiter).start();
new Thread(decrementer).start();

Thread.sleep(4000);
public class Waiter implements Runnalbe{
     CountDownLatch latch=null;
     public Waiter (CountDownLatch latch){
         this.latch=latch;
     }
     public void run(){
         try{
            latch.await();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        System.out.println(&quot;Waiter Released&quot;);
    }
}
public class Decrementer implement Runnable{
     CountDownLatch latch=null;
     public Dcrementer(CountDownLatch latch){
          this.latch=latch;
     }
     public void run(){
        try{
            Thread.sleep(1000);
            this.latch.countDown();

            Thread.sleep(1000);
            this.latch.countDown();
            Thread.sleep(1000);
            this.latch.countDown();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/01/18/Java面试（下）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Java面试（下）
        
      </div>
    </a>
  
  
    <a href="/2017/01/16/Sparkstreming实时处理kafka里数据流/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Sparkstreming实时处理kafka里数据流</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Java面试（上）" data-title="Java面试（上）" data-url="http://yoursite.com/2017/01/18/Java面试（上）/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Mai Taozi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>